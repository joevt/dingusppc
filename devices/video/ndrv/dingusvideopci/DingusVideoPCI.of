\ ========================================================================================
\ PCI header

tokenizer[ D15C 0001 038000 ]tokenizer pci-header
tokenizer[ 20000 ]tokenizer rom-size

\ ========================================================================================

\ the evaluate word might use fcode numbers starting from 0x800 so we'll start at 0x820.
tokenizer[ 820 next-fcode ]tokenizer

fcode-version2

hex

( headerless ) / external

0 value indent
: .dbg ( str len -- )
	over c@ [char] ] = if					\ str len
		indent ?dup if 1- to indent then	\ str len
	then									\ str len
	indent 2* spaces						\ str len
	2dup type								\ str len
	drop									\ str
	c@ [char] [ = if						\
		indent 1+ to indent
	then
	;

" [ DingusVideoParent" .dbg cr

\ ( \ )	" DingusVideoParentTemp" device-name
\ ( \ )	" pwd" evaluate
\ ( \ )	" .properties" evaluate
\ ( \ )	" words" evaluate

	\ ====================================================================================
	\ Debugging utilities

	: .stack " stack:" .dbg depth if 0 depth 2- do space i pick 8 u.r -1 +loop else ."  Empty" then cr ;
	.stack

	0 value save-depth
	: save-stack[ depth to save-depth ;
	: ]restore-stack depth save-depth ?do drop loop ;
	: .saved-stack depth save-depth - begin dup while dup pick space 8 u.r 1- repeat drop cr ;

	\ ====================================================================================
	\ Open Firmware fixes

	" fix $find" .dbg cr
	.stack

	\ $find in Open Firmware 1.0.5 incorrectly returns 4 items on the stack instead of 3 for not found result
	: ($find) ( str len -- xt true | str len false )
		$find		\ xt true | str len false
		dup 0= if	\ pstr str len false
			3 roll	\ str len false pstr
			drop	\ str len false
		then
		;

	defer $def-find
	save-stack[
		" " $find
		depth save-depth - 4 = if
			" $find has problem" .dbg cr
			['] ($find)
		else
			" $find is ok" .dbg cr
			['] $find
		then to $def-find
	]restore-stack

	: (filll) ( addr len word -- )
		-rot bounds		\ word addr+len addr
		?do				\ word
			dup i l!
		/l +loop
		;

	defer my-filll

	" filll" $def-find if
		to my-filll
	else
		2drop
		['] (filll) to my-filll
	then

	.stack

	\ ====================================================================================
	\ Debug logging

	save-stack[ my-address " my-address:" .dbg .saved-stack ]restore-stack \ ( -- phys.lo ... )			0 0
	save-stack[ my-space   " my-space:"   .dbg .saved-stack ]restore-stack \ ( -- phys.hi )				6800		(for PCI slot @D)
	save-stack[ my-unit    " my-unit:"    .dbg .saved-stack ]restore-stack \ ( -- phys.lo ... phys.hi )	0 0 0
	save-stack[ my-args    " my-args:"    .dbg .saved-stack ]restore-stack \ ( -- arg-str arg-len )		0 0

	my-space constant parent-space

	\ ====================================================================================
	\ Structs

	" [ structs" .dbg cr

	struct
		/l field >M.num-displays
	constant /meta-regs

	struct \ display-regs
		/l field >D.hactive
		/l field >D.hsyncbegin
		/l field >D.hsyncend
		/l field >D.htotal
		/l field >D.vactive
		/l field >D.vsyncbegin
		/l field >D.vsyncend
		/l field >D.vtotal
		/l field >D.mon-sense
		/l field >D.timing-flags
		/l field >D.immediate-flags
		/l field >D.pixel-clock
		/l field >D.pixel-depth
		/l field >D.framebuffer-base
		/l field >D.framebuffer-rowbytes
		/l field >D.int-enable
		/l field >D.int-status
		/l field >D.hwcursor-base
		/l field >D.hwcursor-width
		/l field >D.hwcursor-pos
		/l field >D.color-index
		/l field >D.color-data
	constant /display-regs

	struct \ display-timing
		/l field >T.pixel-clock

		/w field >T.mode
		/w field >T.width
		/w field >T.height

		/w field >T.hactive
		/w field >T.hsyncbegin
		/w field >T.hsyncend
		/w field >T.htotal

		/w field >T.vactive
		/w field >T.vsyncbegin
		/w field >T.vsyncend
		/w field >T.vtotal

		/c field >T.hpolarity
		/c field >T.vpolarity
		/c field >T.interlaced
		/c field >T.csyncdisabled

		d# 10 field >T.note
		3 + -4 and
	constant /display-timing \ 40 bytes

	struct \ display-info
		/display-timing field >I.current-timing
		/l field >I.phandle
		/l field >I.display-regs
		/l field >I.fb-base
		/l field >I.fb-address
		/l field >I.fb-row-bytes
		/l field >I.im-flags-to-set
		/l field >I.open-count
		/l field >I.edid
		/w field >I.edid-size
		/w field >I.sense-code
		/c field >I.mono-mode?
		/c field >I.pixel-depth
		/c field >I.display-number
	constant /display-info

	struct \ dmt-entry
		/l field >dmt.id
		/l field >dmt.display-timing
	constant /dmt-entry

	struct \ vic-entry
		/l field >V.display-timing
		/l field >V.vic
	constant /vic-entry

	struct \ sense-code-entry
		/w field >S.sense-code
		/w field >S.monochrome
		/l field >S.display-timing-list
	constant /sense-code

	struct
	(   0 )     8 field >edid.header
	(   8 )     2 field >edid.manufacturer-id
	(  10 )     2 field >edid.manufacturer-product-code
	(  12 )     4 field >edid.serial-number
	(  16 )     2 field >edid.week-and-year-of-manufacture
	(  18 )     1 field >edid.version
	(  19 )     1 field >edid.revision
	(  20 )     1 field >edid.video-input-parameters
	(  21 )     1 field >edid.horizontal-screen-size
	(  22 )     1 field >edid.vertical-screen-size
	(  23 )     1 field >edid.display-gamma
	(  24 )     1 field >edid.supported-features
	(  25 ) d# 10 field >edid.chromaticity-coordinates
	(  35 )     0 field >edid.established-timings
	(  35 )     1 field >edid.established-timings-0
	(  36 )     1 field >edid.established-timings-1
	(  37 )     1 field >edid.established-timings-2
	(  38 ) d# 16 field >edid.standard-timings
	(  54 ) d# 72 field >edid.display-descriptors
	( 126 )     1 field >edid.number-of-extensions
	( 127 )     1 field >edid.checksum
	( 128 )     0 field >edid.next-block
	( 128 ) constant /edid-base

	struct \ detailed-timing-descriptor
	(  0 ) /w field >dtd.pixel-clock
	(  2 ) /c field >dtd.hact
	(  3 ) /c field >dtd.hbl
	(  4 ) /c field >dtd.hact,hbl
	(  5 ) /c field >dtd.vact
	(  6 ) /c field >dtd.vbl
	(  7 ) /c field >dtd.vact,vbl
	(  8 ) /c field >dtd.hfp
	(  9 ) /c field >dtd.hsp
	( 10 ) /c field >dtd.vfp,vsp
	( 11 ) /c field >dtd.hfp,hsp,vfp,vsp
	( 12 ) /c field >dtd.hsize
	( 13 ) /c field >dtd.vsize
	( 14 ) /c field >dtd.hsize,vsize
	( 15 ) /c field >dtd.hborder
	( 16 ) /c field >dtd.vborder
	( 17 ) /c field >dtd.features
	( 18 )  0 field >dtd.next-dtd
	( 18 ) constant /dtd

	" ] structs" .dbg cr

	\ ====================================================================================
	\ Miscellaneous

	\ this differs from the one in ROM since it will check for zero length
	: $c, bounds ?do i c@ c, loop ;

	: c!++ ( val adr -- adr+1 )
		tuck c! 1+ ;
		;

	: c@++ ( adr -- c adr+1 )
		dup c@ swap 1+ ;

	: 4c!-be ( l a -- )
		>r lbsplit r> c!++ c!++ c!++ c! ;

	: 2c@-le ( a -- w )
		c@++ c@ bwjoin ;

	: 3c@-le ( a -- l )
		c@++ c@++ c@ 0 bljoin ;

	: 4c@-le ( a -- l )
		c@++ c@++ c@++ c@ bljoin ;

	\ ====================================================================================
	\ Math

	\ *			( nu1 nu2 -- prod )					\ 0x20 Multiply nu1 by nu2.
	\ /			( n1 n2 -- quot )					\ 0x21 Divide n1 by n2; return quotient.
	\ /mod		( n1 n2 -- rem quot )				\ 0x2A Divide n1 by n2; return remainder and quotient.
	\ 2/		( n -- (n >>a 2) )					\ 0x57 Shift x1 right by one bit-place. High bit unchanged.
	\ u2/		( u -- (u >> 2) )					\ 0x58 Shift x1 right by one bit-place. Zero-fill high bit.
	\ um*		( u1 u2 -- ud )						\ 0xD4 Unsigned multiply with unsigned double number product.
	\ d+		( d1 d2 -- d.sum )					\ 0xD8 Add d1 to d2 giving double number d.sum.
	\ d-		( d1 d2 -- d.diff )					\ 0xD9 Subtract d2 from d1 giving double number d.diff.

	\ s>d		( n1 -- d1 )						\ .... Convert a number to a double number.
	\ m*		( n1 n2 -- d )						\ .... Signed multiply with double number product.
	\ fm/mod	( d n -- rem quot )					\ .... Divide d by n.
	\ sm/rem	( d n -- rem quot )					\ .... Divide d by n, symmetric division.
	\ */		( n1 n2 n3 -- quot )				\ .... Calculate n1 times n2 divided by n3.
	\ */mod		( n1 n2 n3 -- rem quot )			\ .... Calculate n1 times n2 divided by n3.

	\ ummm/mod	( nl.h dl.h -- ureml.h uquotl.h )	\ .... u64/u64=u64 r64 (joevt)
	\ umm/mod	( ud u -- urem udquot )				\ .... u64/u32=u64 r32 (joevt)
	\ um/mod	( ud u -- urem uquot )				\ 0xD5 u64/u32=u32 r32 (Open Firmware)
	\ u/mod		( u1 u2 -- urem uquot )				\ 0x2B u32/u32=u32 r32 (Open Firmware)

	\ ummm/round ( nl.h dl.h -- uquotl.h )			\ .... u64/u64=u64 (joevt)
	\ umm/round	( ud u -- udquot )					\ .... u64/u32=u64 (joevt)
	\ um/round	( ud u -- uquot )					\ .... u64/u32=u32 (joevt)
	\ u/round	( u1 u -- uquot )					\ .... u32/u32=u32 (joevt)

	\ ummm/		( nl.h dl.h -- uquotl.h )			\ .... u64/u64=u64 (joevt)
	\ um/		( ud u -- udquot )					\ .... u64/u32=u64 (Apple)

	\ ud*		( ud u -- udproduct )				\ .... u64*u32=u64 (joevt)
	\ d2*		( d -- d<<1 )						\ .... (Apple)

	\ //		( ? -- ? )							\ .... (Apple)
	\ u/		( u -- uquot )						\ .... (Apple)

	\ d2/		( d -- (d >>a 1) )					\ .... (Apple)
	\ ud2/		( ud -- (ud >> 1) )					\ .... (Apple)
	\ mu/mod	( ud u1 -- u2 u3 )					\ .... ?

	\ d<		( ud1 ud2 -- d< )					\ .... (Apple)
	\ d=		( ud1 ud2 -- d= )					\ .... (Apple)
	\ d<>		( ud1 ud2 -- d<> )					\ .... (Apple)
	\ du<		( ud1 ud2 -- du< )					\ .... (Apple)


	: isqrt ( n -- √n )
		40000000						\ n d=1<<30				\	d = 1 << 30
		begin							\ n d
			2dup						\ n d n d
			u<							\ n d n<d				\	while (d > n) {
		while							\ n d
			2 >>						\ n d>>=2				\		d >>= 2
		repeat							\ n d					\	}
										\ x d					\	x = n
		0								\ x d c=0				\	c = 0
		begin							\ x d c
			over						\ x d c d
		while							\ x d c					\	while (d != 0) {
			2dup + dup >r				\ x d c d+c \ R: d+c
			3 pick u<=					\ x d c d+c<=x \ R: d+c
			if							\ x d c \ R: d+c		\		if (x >= c + d) {
				rot r> -				\ d c x=x-d+c			\			x -= c + d
				-rot u2/ over +			\ x d c=c>>1+d			\			c = (c >> 1) + d
			else						\ x d c \ R: d+c		\		} else {
				r> drop					\ x d c
				u2/						\ x d c>>=1				\			c >>= 1
			then						\ x d c					\		}
			swap 2 >> swap				\ x d>>=2 c				\		d >>= 2
		repeat							\ x d c					\	}
		nip nip							\ c						\	return c
		;


\ Slow 64 bit divide method:
\
\ if D = 0 then error(DivisionByZeroException) end
\ Q := 0                  -- Initialize quotient and remainder to zero
\ R := 0
\ for i := n − 1 .. 0 do  -- Where n is number of bits in N
\   R := R << 1           -- Left-shift R by 1 bit
\   R(0) := N(i)          -- Set the least-significant bit of R equal to bit i of the numerator
\   if R ≥ D then
\     R := R − D
\     Q(i) := 1
\   end
\ end
\
\

	: d2* ( ud -- ud<<=1 )
		2dup d+ ;

	: 2roll ( u -- )
		2* 1+ dup >r roll r> roll ;

	: 2pick ( u -- )
		2* 1+ dup >r pick r> pick ;

	: 2nip
		2swap 2drop ;

	: du< ( ud1 ud2 -- <? )
		rot 2dup u> >r = >r u< r> and r> or ; \ ((l1<l2 & h2==h1) | h2<h1)

	: .ud ( ud1 -- )
		8 u.r 8 u.r ;

	: ummm/mod ( nl.h dl.h -- ureml.h uquotl.h )
\		cr
		2swap									\ dl.h nl.h
		0 0 0 0									\ dl.h nl.h rl.h=0 ql.h=0.0
		d# 64 0 do								\ dl.h nl.h rl.h ql.h
\			i 2 u.r ." .01: " 2 2pick .ud space 2dup .ud space 2over .ud cr
			d2*									\ dl.h nl.h rl.h ql.h<<=1
\			i 2 u.r ." .02: " 2 2pick .ud space 2dup .ud space 2over .ud cr
			2swap								\ dl.h nl.h ql.h rl.h
\			i 2 u.r ." .03: " 2 2pick .ud space 2over .ud space 2dup .ud cr
			d2*									\ dl.h nl.h ql.h rl.h<<=1
\			i 2 u.r ." .04: " 2 2pick .ud space 2over .ud space 2dup .ud cr
			2rot								\ dl.h ql.h rl.h nl.h
\			i 2 u.r ." .05: " 2dup .ud space 2 2pick .ud space 2over .ud cr
			dup 0< negate >r d2*				\ dl.h ql.h rl.h nl.h<<=1 \ R: n<0?1:0
\			i 2 u.r ." .06: " 2dup .ud space 2 2pick .ud space 2over .ud cr
			2swap r> 0 d+						\ dl.h ql.h nl.h rl.h+=n<0?1:0
\			i 2 u.r ." .07: " 2over .ud space 2 2pick .ud space 2dup .ud cr
			2dup 4 2pick du< if					\ dl.h ql.h nl.h rl.h ( rl.h<dl.h -- )
\			i 2 u.r ." .08: " 2over .ud space 2 2pick .ud space 2dup .ud cr
				2rot							\ dl.h nl.h rl.h ql.h
\			i 2 u.r ." .09: " 2 2pick .ud space 2dup .ud space 2over .ud cr
			else								\ dl.h ql.h nl.h rl.h
				3 2pick d-						\ dl.h ql.h nl.h rl.h-=dl.h
\			i 2 u.r ." .10: " 2over .ud space 2 2pick .ud space 2dup .ud cr
				2rot swap 1+ swap				\ dl.h nl.h rl.h ql.h|=1
\			i 2 u.r ." .11: " 2 2pick .ud space 2dup .ud space 2over .ud cr
			then								\ dl.h nl.h rl.h ql.h
		loop									\ dl.h nl.h rl.h ql.h
		>r >r >r >r 2drop 2drop r> r> r> r>		\ rl.h ql.h
		;

	: ummm/ ( nl.h dl.h -- uquotl.h )
		ummm/mod 2nip ;

	: ummm/round ( nl.h dl.h -- uquotl.h )
		2dup >r >r			\ nl.h dl.h \ R: dl.h
		ummm/mod			\ ureml.h uquotl.h \ R: dl.h
		2swap 2dup r> r>	\ uquotl.h ureml.h ureml.h dl.h
		2swap d-			\ uquotl.h ureml.h dl.h-ureml.h
		du< 1+				\ uquotl.h ((ureml.h>=dl.h-ureml.h)?1:0)
		0 d+				\ uquotl.h+ ((ureml.h>=dl.h-ureml.h)?1:0)
		;

	: umm/mod ( nl.h d -- urem uquotl.h )
		0 0 0									\ nl.h d r=0 ql.h=0.0
		d# 64 0 do								\ nl.h d r ql.h
			d2*									\ nl.h d r ql.h<<=1
			2swap								\ nl.h ql.h d r
			2*									\ nl.h ql.h d r<<=1
			2rot								\ ql.h d r nl.h
			dup 0< negate >r d2*				\ ql.h d r nl.h<<=1 \ n<0?1:0
			2swap r> +							\ ql.h nl.h d r+=n<0?1:0
			2dup u<= if							\ ql.h nl.h d r
				over -							\ ql.h nl.h d r-=d
				2rot swap 1+ swap				\ nl.h d r ql.h|=1
			else								\ ql.h nl.h d r
				2rot							\ nl.h d r ql.h
			then								\ nl.h d r ql.h
		loop									\ nl.h d r ql.h
		>r >r >r 3drop r> r> r>					\ r ql.h
		;

	\ Override Apple's broken implementation:
	: um/mod ( ud u -- urem uquot )
		umm/mod		\ urem udquot
		drop		\ urem uquot
		;


\ For u64/16=64r32
\
\             __a/x______mb/x_____nc/x_____od/x_____r = p
\           x ) a        b        c        d
\              m=a%x    b
\                       n=mb%x   c
\                                o=nc%x   d
\                                         p=od%x
\
\
\ A diviser greater than 16 bits doesn't work. For example:
\
\             __0000_____d00f_____nc/x_____od/x_____r = p
\       12c64 ) f424     0000     0000     0000
\               f424     0000
\                       12624     0000
\                too big^         o=nc%x   0000
\                                          p=od%x
\
\             __0000_____0004_____nc/x_____od/x_____r = p
\       12c64 )    5     d7b4     0000     0000
\                  5     d7b4
\                       12624     0000
\                too big^         o=nc%x   0000
\                                          p=od%x
\
\	: u64/16=64r32 ( cd32 ab32 x16 -- urem16 udquot64 )
\		-rot												\ x cd ab
\		lwsplit												\ x cd b a
\		3 pick u/mod 2dup . . cr >r							\ x cd b m=a%x \ R: a/x
\		wljoin 2 pick u/mod 2dup . . cr >r					\ x cd n=mb%x \ R: a/x mb/x
\		>r lwsplit r> wljoin 2 pick u/mod 2dup . . cr >r	\ x d o=nc%x \ R: a/x mb/x nc/x
\		wljoin swap u/mod 2dup . .							\ p=od%x od/x \ R: a/x mb/x nc/x
\		r> wljoin r> r> wljoin								\ p=od%x nc/x.od/x a/x.mb/x
\		;


\ This is for timing um/mod
\	: my-um/mod
\		cr
\		3dup >r >r >r					\ l h d \ R: d h l
\		get-msecs >r					\ l h d \ R: d h l msb
\		um/mod							\ r q \ R: d h l
\		get-msecs r> - dup d# 1000 > if	\ r q \ R: d h l
\			." time: " .d
\			r> r> r>					\ r q l h d
\			2 pick . over . dup .		\ r q
\			3drop ." = "
\			2dup swap . . cr			\ r q
\		else							\ r q \ R: d h l
\			drop
\			r> r> r>					\ r q l h d
\			3drop						\ r q
\		then							\ r q l h d
\		;


\	\ This doesn't work because alarm is not preemptive
\	\ or will not interrupt um/mod
\
\	0 value save-d
\	0 value save-l
\	0 value save-h
\
\	: my-alarm
\		['] my-alarm 0 alarm
\		user-abort
\		;
\
\	: my-um/mod2
\		['] my-alarm d# 1000 alarm
\		1 0 do
\			um/mod
\		loop
\		['] my-alarm 0 alarm
\		;
\
\	: my-um/mod3
\		3dup
\		to save-l
\		to save-h
\		to save-d
\		['] my-um/mod2 catch ?dup if
\			." error" . save-h . save-l . save-d . cr
\		then
\		;


\ For um/ and umm/mod and umm/round
\
\	   _______h/d___h%d.l/d__ r h%d.l%d
\	d )         h         l
\       -   h/d*d
\       -------------------
\	          h%d         l
\       -         h%d.l/d*d
\       -------------------
\	                h%d.l%d
\
\	: umm/mod ( l.h u -- urem udquot ) \ u64/u32=u64 r32
\		tuck		\ l d h d
\		u/mod		\ l d h%d h/d
\		>r			\ l d h%d \ R: h/d
\		swap		\ l h%d d \ R: h/d
\		um/mod		\ h%d.l%d h%d.l/d \ R: h/d
\		r>			\ h%d.l%d h%d.l/d h/d
\		;

	: um/ ( l.h u -- udquot ) \ u64/u32=u64
		umm/mod		\ urem udquot
		rot drop	\ udquot
		;

	: umm/round ( l.h u -- udquot ) \ u64/u32=u64
		dup >r		\ l.h u \ R: u
		umm/mod		\ urem udquot \ R: u
		rot dup r>	\ udquot urem urem u
		swap -		\ udquot urem u-urem
		>= negate	\ udquot ((urem>=u-urem)?1:0)
		0 d+		\ udquot+ ((urem>=u-urem)?1:0)
		;

	: um/round ( ud u -- uquot ) \ u64/u32=u32
		dup >r		\ ud u \ R: u
		um/mod		\ urem uquot \ R: u
		swap dup r>	\ uquot urem urem u
		swap -		\ uquot urem u-urem
		>= negate +	\ uquot+((urem>=u-urem)?1:0)
		;

	: u/round ( u1 u -- uquot )
		tuck		\ u u1 u
		u/mod		\ u urem uquot
		-rot		\ uquot u urem
		tuck -		\ uquot urem u-urem
		>= negate +	\ uquot + ((urem>=u-urem)?1:0)
		;

	: ud* ( ab c -- udproduct ) \ u64*u32=u64
		tuck um* drop >r	\ b c \ R: acl
		um*					\ bcl bch \ R: acl
		r> +				\ bcl bch+acl
		;

	\ ====================================================================================
	\ Data

	" [ timings" .dbg cr

	decimal

	defer timing-proc ( display-timing display-info -- done? )

	false constant N
	true  constant P
	: mode, 18 0 do i roll loop                   l,   w,    w,    w,    w,    w,    w,    w,     w,    w,    w,    w, c, c, c,     c,     over $c, 10 swap ?do 0 c, loop ;

	create kDisplay_512x384i_60Hz_NTSC       654400  100   512   384   512   488   528   544    384   385   388   393  N  P  true   false  " NTSC"         mode, \ not accurate (calculated using GTF)
	create kDisplay_640x480i_50Hz_PAL        835000  102   640   480   640   600   656   672    480   481   484   489  N  P  true   false  " PAL"          mode, \ not accurate (calculated using GTF)
	create kDisplay_768x576i_50Hz_PAL       1261400  108   768   576   768   744   808   848    576   577   580   586  N  P  true   false  " PAL"          mode, \ not accurate (calculated using GTF)
	create kDisplay_640x480_120Hz           5240600  106   640   480   640   680   744   848    480   481   484   515  N  P  false  false  0 0             mode,
	create kDisplay_640x480i_60Hz_NTSC      1227000  200   640   480   640   664   724   780    480   486   492   525  0  0  true   false  " NTSC"         mode,
	create kDisplay_512x342_60Hz            1566720  201   512   342   512   526   529   704    342   343   347   370  0  0  false  false  0 0             mode,
	create kDisplay_512x384_60Hz            1566720  202   512   384   512   528   560   640    384   385   388   407  0  0  false  false  0 0             mode,
	create kDisplay_560x384_60Hz            1723400  203   560   384   560   592   624   704    384   385   388   407  0  0  false  false  0 0             mode,
	create kDisplay_640x400_67Hz            3024000  205   640   400   640   704   768   864    400   443   446   525  0  0  false  false  0 0             mode,
	create kDisplay_640x870_75Hz            5728320  218   640   870   640   672   752   832    870   873   876   918  0  0  false  false  0 0             mode,
	create kDisplay_1024x768_75Hz           8000000  223  1024   768  1024  1056  1152  1328    768   771   774   804  0  0  false  false  0 0             mode,
	create kDisplay_1280x960_75Hz          12600000  228  1280   960  1280  1296  1440  1680    960   961   964  1000  0  0  false  false  0 0             mode,
	create kDisplay_720x400_70Hz            2832000  300   720   400   720   738   846   900    400   421   423   449  N  P  false  false  0 0             mode,
	create kDisplay_720x400_88Hz            3550000  301   720   400   720   738   846   900    400   412   414   449  N  P  false  false  0 0             mode,
	create kDisplay_640x480_67Hz            3024000  303   640   480   640   704   768   864    480   483   486   525  N  N  false  false  0 0             mode,
	create kDisplay_832x624_75Hz            5728320  310   832   624   832   864   928  1152    624   625   628   667  N  N  false  false  0 0             mode,
	create kDisplay_1152x870_75Hz          10000000  316  1152   870  1152  1184  1312  1456    870   873   876   915  P  P  false  false  0 0             mode,
	create kDisplay_640x350_85Hz            3150000  401   640   350   640   672   736   832    350   382   385   445  P  N  false  false  0 0             mode,
	create kDisplay_640x400_85Hz            3150000  402   640   400   640   672   736   832    400   401   404   445  N  P  false  false  0 0             mode,
	create kDisplay_720x400_85Hz            3550000  403   720   400   720   756   828   936    400   401   404   446  N  P  false  false  0 0             mode,
	create kDisplay_640x480_60Hz_VGA        2517500  404   640   480   640   656   752   800    480   490   492   525  N  N  false  false  " VGA"          mode,
	create kDisplay_640x480_72Hz            3150000  405   640   480   640   664   704   832    480   489   492   520  N  N  false  false  0 0             mode,
	create kDisplay_640x480_75Hz            3150000  406   640   480   640   656   720   840    480   481   484   500  N  N  false  false  0 0             mode,
	create kDisplay_640x480_85Hz            3600000  407   640   480   640   696   752   832    480   481   484   509  N  N  false  false  0 0             mode,
	create kDisplay_800x600_56Hz_VGA        3600000  408   800   600   800   824   896  1024    600   601   603   625  P  P  false  false  " VGA"          mode,
	create kDisplay_800x600_60Hz_VGA        4000000  409   800   600   800   840   968  1056    600   601   605   628  P  P  false  false  " VGA"          mode,
	create kDisplay_800x600_72Hz_VGA        5000000  410   800   600   800   856   976  1040    600   637   643   666  P  P  false  false  " VGA"          mode,
	create kDisplay_800x600_75Hz_VGA        4950000  411   800   600   800   816   896  1056    600   601   604   625  P  P  false  false  " VGA"          mode,
	create kDisplay_800x600_85Hz            5625000  412   800   600   800   832   896  1048    600   601   604   631  P  P  false  false  0 0             mode,
	create kDisplay_800x600_120Hz           7325000  413   800   600   800   848   880   960    600   603   607   636  P  N  false  false  0 0             mode,
	create kDisplay_848x480_60Hz            3375000  414   848   480   848   864   976  1088    480   486   494   517  P  P  false  false  0 0             mode,
	create kDisplay_1024x768i_87Hz          4490000  415  1024   768  1024  1032  1208  1264    768   769   777   817  P  P  true   false  0 0             mode,
	create kDisplay_1024x768_60Hz_VGA       6500000  416  1024   768  1024  1048  1184  1344    768   771   777   806  N  N  false  false  " VGA"          mode,
	create kDisplay_1024x768_70Hz           7500000  417  1024   768  1024  1048  1184  1328    768   771   777   806  N  N  false  false  0 0             mode,
	create kDisplay_1024x768_75Hz_VGA       7875000  418  1024   768  1024  1040  1136  1312    768   769   772   800  P  P  false  false  " VGA"          mode,
	create kDisplay_1024x768_85Hz           9450000  419  1024   768  1024  1072  1168  1376    768   769   772   808  P  P  false  false  0 0             mode,
	create kDisplay_1024x768_120Hz         11550000  420  1024   768  1024  1072  1104  1184    768   771   775   813  P  N  false  false  0 0             mode,
	create kDisplay_1152x864_75Hz          10800000  421  1152   864  1152  1216  1344  1600    864   865   868   900  P  P  false  false  0 0             mode,
	create kDisplay_1280x720_60Hz           7425000  422  1280   720  1280  1390  1430  1650    720   725   730   750  P  P  false  false  0 0             mode,
	create kDisplay_1280x768_60Hz_RB        6825000  423  1280   768  1280  1328  1360  1440    768   771   778   790  P  N  false  false  " RB"           mode,
	create kDisplay_1280x768_59_87Hz        7950000  424  1280   768  1280  1344  1472  1664    768   771   778   798  N  P  false  false  0 0             mode,
	create kDisplay_1280x768_75Hz          10225000  425  1280   768  1280  1360  1488  1696    768   771   778   805  N  P  false  false  0 0             mode,
	create kDisplay_1280x768_85Hz          11750000  426  1280   768  1280  1360  1496  1712    768   771   778   809  N  P  false  false  0 0             mode,
	create kDisplay_1280x768_120Hz         14025000  427  1280   768  1280  1328  1360  1440    768   771   778   813  P  N  false  false  0 0             mode,
	create kDisplay_1280x800_60Hz_RB        7100000  428  1280   800  1280  1328  1360  1440    800   803   809   823  P  N  false  false  " RB"           mode,
	create kDisplay_1280x800_60Hz           8350000  429  1280   800  1280  1352  1480  1680    800   803   809   831  N  P  false  false  0 0             mode,
	create kDisplay_1280x800_75Hz          10650000  430  1280   800  1280  1360  1488  1696    800   803   809   838  N  P  false  false  0 0             mode,
	create kDisplay_1280x800_85Hz          12250000  431  1280   800  1280  1360  1496  1712    800   803   809   843  N  P  false  false  0 0             mode,
	create kDisplay_1280x800_120Hz         14625000  432  1280   800  1280  1328  1360  1440    800   803   809   847  P  N  false  false  0 0             mode,
	create kDisplay_1280x960_60Hz          10800000  433  1280   960  1280  1376  1488  1800    960   961   964  1000  P  P  false  false  0 0             mode,
	create kDisplay_1280x960_85Hz          14850000  434  1280   960  1280  1344  1504  1728    960   961   964  1011  P  P  false  false  0 0             mode,
	create kDisplay_1280x960_120Hz         17550000  435  1280   960  1280  1328  1360  1440    960   963   967  1017  P  N  false  false  0 0             mode,
	create kDisplay_1280x1024_60Hz         10800000  436  1280  1024  1280  1328  1440  1688   1024  1025  1028  1066  P  P  false  false  0 0             mode,
	create kDisplay_1280x1024_75Hz         13500000  437  1280  1024  1280  1296  1440  1688   1024  1025  1028  1066  P  P  false  false  0 0             mode,
	create kDisplay_1280x1024_85Hz         15750000  438  1280  1024  1280  1344  1504  1728   1024  1025  1028  1072  P  P  false  false  0 0             mode,
	create kDisplay_1280x1024_120Hz        18725000  439  1280  1024  1280  1328  1360  1440   1024  1027  1034  1084  P  N  false  false  0 0             mode,
	create kDisplay_1360x768_60Hz           8550000  440  1360   768  1360  1424  1536  1792    768   771   777   795  P  P  false  false  0 0             mode,
	create kDisplay_1360x768_120Hz         14825000  441  1360   768  1360  1408  1440  1520    768   771   776   813  P  N  false  false  0 0             mode,
	create kDisplay_1366x768_60Hz           8550000  442  1366   768  1366  1436  1579  1792    768   771   774   798  P  P  false  false  0 0             mode,
	create kDisplay_1366x768_60Hz_RB        7200000  443  1366   768  1366  1380  1436  1500    768   769   772   800  P  P  false  false  " RB"           mode,
	create kDisplay_1400x1050_60Hz_RB      10100000  444  1400  1050  1400  1448  1480  1560   1050  1053  1057  1080  P  N  false  false  " RB"           mode,
	create kDisplay_1400x1050_60Hz         12175000  445  1400  1050  1400  1488  1632  1864   1050  1053  1057  1089  N  P  false  false  0 0             mode,
	create kDisplay_1400x1050_75Hz         15600000  446  1400  1050  1400  1504  1648  1896   1050  1053  1057  1099  N  P  false  false  0 0             mode,
	create kDisplay_1400x1050_85Hz         17950000  447  1400  1050  1400  1504  1656  1912   1050  1053  1057  1105  N  P  false  false  0 0             mode,
	create kDisplay_1400x1050_120Hz        20800000  448  1400  1050  1400  1448  1480  1560   1050  1053  1057  1112  P  N  false  false  0 0             mode,
	create kDisplay_1440x900_60Hz_RB        8875000  449  1440   900  1440  1488  1520  1600    900   903   909   926  P  N  false  false  " RB"           mode,
	create kDisplay_1440x900_60Hz          10650000  450  1440   900  1440  1520  1672  1904    900   903   909   934  N  P  false  false  0 0             mode,
	create kDisplay_1440x900_75Hz          13675000  451  1440   900  1440  1536  1688  1936    900   903   909   942  N  P  false  false  0 0             mode,
	create kDisplay_1440x900_85Hz          15700000  452  1440   900  1440  1544  1696  1952    900   903   909   948  N  P  false  false  0 0             mode,
	create kDisplay_1440x900_120Hz         18275000  453  1440   900  1440  1488  1520  1600    900   903   909   953  P  N  false  false  0 0             mode,
	create kDisplay_1600x900_60Hz          10800000  454  1600   900  1600  1624  1704  1800    900   901   904  1000  P  P  false  false  0 0             mode,
	create kDisplay_1600x1200_60Hz         16200000  455  1600  1200  1600  1664  1856  2160   1200  1201  1204  1250  P  P  false  false  0 0             mode,
	create kDisplay_1600x1200_65Hz         17550000  456  1600  1200  1600  1664  1856  2160   1200  1201  1204  1250  P  P  false  false  0 0             mode,
	create kDisplay_1600x1200_70Hz         18900000  457  1600  1200  1600  1664  1856  2160   1200  1201  1204  1250  P  P  false  false  0 0             mode,
	create kDisplay_1600x1200_75Hz         20250000  458  1600  1200  1600  1664  1856  2160   1200  1201  1204  1250  P  P  false  false  0 0             mode,
	create kDisplay_1600x1200_85Hz         22950000  459  1600  1200  1600  1664  1856  2160   1200  1201  1204  1250  P  P  false  false  0 0             mode,
	create kDisplay_1600x1200_120Hz        26825000  460  1600  1200  1600  1648  1680  1760   1200  1203  1207  1271  P  N  false  false  0 0             mode,
	create kDisplay_1680x1050_60Hz_RB      11900000  461  1680  1050  1680  1728  1760  1840   1050  1053  1059  1080  P  N  false  false  " RB"           mode,
	create kDisplay_1680x1050_60Hz         14625000  462  1680  1050  1680  1784  1960  2240   1050  1053  1059  1089  N  P  false  false  0 0             mode,
	create kDisplay_1680x1050_75Hz         18700000  463  1680  1050  1680  1800  1976  2272   1050  1053  1059  1099  N  P  false  false  0 0             mode,
	create kDisplay_1680x1050_85Hz         21475000  464  1680  1050  1680  1808  1984  2288   1050  1053  1059  1105  N  P  false  false  0 0             mode,
	create kDisplay_1680x1050_120Hz        24550000  465  1680  1050  1680  1728  1760  1840   1050  1053  1059  1112  P  N  false  false  0 0             mode,
	create kDisplay_1792x1344_60Hz         20475000  466  1792  1344  1792  1920  2120  2448   1344  1345  1348  1394  N  P  false  false  0 0             mode,
	create kDisplay_1792x1344_75Hz         26100000  467  1792  1344  1792  1888  2104  2456   1344  1345  1348  1417  N  P  false  false  0 0             mode,
	create kDisplay_1792x1344_120Hz        33325000  468  1792  1344  1792  1840  1872  1952   1344  1347  1351  1423  P  N  false  false  0 0             mode,
	create kDisplay_1856x1392_60Hz         21825000  469  1856  1392  1856  1952  2176  2528   1392  1393  1396  1439  N  P  false  false  0 0             mode,
	create kDisplay_1856x1392_75Hz         28800000  470  1856  1392  1856  1984  2208  2560   1392  1393  1396  1500  N  P  false  false  0 0             mode,
	create kDisplay_1856x1392_120Hz        35650000  471  1856  1392  1856  1904  1936  2016   1392  1395  1399  1473  P  N  false  false  0 0             mode,
	create kDisplay_1920x1080_60Hz         14850000  472  1920  1080  1920  2008  2052  2200   1080  1084  1089  1125  P  P  false  false  0 0             mode,
	create kDisplay_1920x1200_60Hz_RB      15400000  473  1920  1200  1920  1968  2000  2080   1200  1203  1209  1235  P  N  false  false  " RB"           mode,
	create kDisplay_1920x1200_60Hz         19325000  474  1920  1200  1920  2056  2256  2592   1200  1203  1209  1245  N  P  false  false  0 0             mode,
	create kDisplay_1920x1200_75Hz         24525000  475  1920  1200  1920  2056  2264  2608   1200  1203  1209  1255  N  P  false  false  0 0             mode,
	create kDisplay_1920x1200_85Hz         28125000  476  1920  1200  1920  2064  2272  2624   1200  1203  1209  1262  N  P  false  false  0 0             mode,
	create kDisplay_1920x1200_120Hz        31700000  477  1920  1200  1920  1968  2000  2080   1200  1203  1209  1271  P  N  false  false  0 0             mode,
	create kDisplay_1920x1440_60Hz         23400000  478  1920  1440  1920  2048  2256  2600   1440  1441  1444  1500  N  P  false  false  0 0             mode,
	create kDisplay_1920x1440_75Hz         29700000  479  1920  1440  1920  2064  2288  2640   1440  1441  1444  1500  N  P  false  false  0 0             mode,
	create kDisplay_1920x1440_120Hz        38050000  480  1920  1440  1920  1968  2000  2080   1440  1442  1445  1523  P  N  false  false  0 0             mode,
	create kDisplay_2048x1152_60Hz         16200000  481  2048  1152  2048  2074  2154  2250   1152  1153  1156  1200  P  P  false  false  0 0             mode,
	create kDisplay_2560x1600_60Hz_RB      26850000  482  2560  1600  2560  2608  2640  2720   1600  1603  1609  1646  P  N  false  false  " RB"           mode,
	create kDisplay_2560x1600_60Hz         34850000  483  2560  1600  2560  2752  3032  3504   1600  1603  1609  1658  N  P  false  false  0 0             mode,
	create kDisplay_2560x1600_75Hz         44325000  484  2560  1600  2560  2768  3048  3536   1600  1603  1609  1672  N  P  false  false  0 0             mode,
	create kDisplay_2560x1600_85Hz         50525000  485  2560  1600  2560  2768  3048  3536   1600  1603  1609  1682  N  P  false  false  0 0             mode,
	create kDisplay_2560x1600_120Hz        55275000  486  2560  1600  2560  2608  2640  2720   1600  1603  1609  1694  P  N  false  false  0 0             mode,
	create kDisplay_4096x2160_60Hz_RB      55674400  487  4096  2160  4096  4104  4136  4176   2160  2208  2216  2222  P  N  false  false  " RB"           mode,
	create kDisplay_4096x2160_59_94Hz      55618800  488  4096  2160  4096  4104  4136  4176   2160  2208  2216  2222  P  N  false  false  0 0             mode,
	create kDisplay_720x480_60Hz            2700000  502   720   480   720   736   798   858    480   489   495   525  N  N  false  false  0 0             mode,
	create kDisplay_1920x1080i_60Hz         7425000  505  1920  1080  1920  2008  2052  2200   1080  1082  1087  1103  P  P  true   false  0 0             mode,
	create kDisplay_1440x480i_60Hz          2700000  506  1440   480  1440  1478  1602  1716    480   484   487   503  N  N  true   false  0 0             mode,
	create kDisplay_1440x240_60Hz           2700000  508  1440   240  1440  1478  1602  1716    240   244   247   262  N  N  false  false  0 0             mode,
	create kDisplay_2880x480i_60Hz          5400000  510  2880   480  2880  2956  3204  3432    480   484   487   503  N  N  true   false  0 0             mode,
	create kDisplay_2880x240_60Hz           5400000  512  2880   240  2880  2956  3204  3432    240   244   247   262  N  N  false  false  0 0             mode,
	create kDisplay_1440x480_60Hz           5400000  514  1440   480  1440  1472  1596  1716    480   489   495   525  N  N  false  false  0 0             mode,
	create kDisplay_720x576_50Hz            2700000  517   720   576   720   732   796   864    576   581   586   625  N  N  false  false  0 0             mode,
	create kDisplay_1280x720_50Hz           7425000  519  1280   720  1280  1720  1760  1980    720   725   730   750  P  P  false  false  0 0             mode,
	create kDisplay_1920x1080i_50Hz         7425000  520  1920  1080  1920  2448  2492  2640   1080  1082  1087  1103  P  P  true   false  0 0             mode,
	create kDisplay_1440x576i_50Hz          2700000  521  1440   576  1440  1464  1590  1728    576   578   581   601  N  N  true   false  0 0             mode,
	create kDisplay_1440x288_50Hz           2700000  523  1440   288  1440  1464  1590  1728    288   290   293   312  N  N  false  false  0 0             mode,
	create kDisplay_2880x576i_50Hz          5400000  525  2880   576  2880  2928  3180  3456    576   578   581   601  N  N  true   false  0 0             mode,
	create kDisplay_2880x288_50Hz           5400000  527  2880   288  2880  2928  3180  3456    288   290   293   312  N  N  false  false  0 0             mode,
	create kDisplay_1440x576_50Hz           5400000  529  1440   576  1440  1464  1592  1728    576   581   586   625  N  N  false  false  0 0             mode,
	create kDisplay_1920x1080_50Hz         14850000  531  1920  1080  1920  2448  2492  2640   1080  1084  1089  1125  P  P  false  false  0 0             mode,
	create kDisplay_1920x1080_24Hz          7425000  532  1920  1080  1920  2558  2602  2750   1080  1084  1089  1125  P  P  false  false  0 0             mode,
	create kDisplay_1920x1080_25Hz          7425000  533  1920  1080  1920  2448  2492  2640   1080  1084  1089  1125  P  P  false  false  0 0             mode,
	create kDisplay_1920x1080_30Hz          7425000  534  1920  1080  1920  2008  2052  2200   1080  1084  1089  1125  P  P  false  false  0 0             mode,
	create kDisplay_2880x480_60Hz          10800000  535  2880   480  2880  2944  3192  3432    480   489   495   525  N  N  false  false  0 0             mode,
	create kDisplay_2880x576_50Hz          10800000  537  2880   576  2880  2928  3184  3456    576   581   586   625  N  N  false  false  0 0             mode,
	create kDisplay_1920x1080i_50Hz_72MHz   7200000  539  1920  1080  1920  1952  2120  2304   1080  1103  1108  1165  P  N  true   false  " 72 MHz"       mode,
	create kDisplay_1920x1080i_100Hz       14850000  540  1920  1080  1920  2448  2492  2640   1080  1082  1087  1103  P  P  true   false  0 0             mode,
	create kDisplay_1280x720_100Hz         14850000  541  1280   720  1280  1720  1760  1980    720   725   730   750  P  P  false  false  0 0             mode,
	create kDisplay_720x576_100Hz           5400000  542   720   576   720   732   796   864    576   581   586   625  N  N  false  false  0 0             mode,
	create kDisplay_1440x576i_100Hz         5400000  544  1440   576  1440  1464  1590  1728    576   578   581   601  N  N  true   false  0 0             mode,
	create kDisplay_1920x1080i_120Hz       14850000  546  1920  1080  1920  2008  2052  2200   1080  1082  1087  1103  P  P  true   false  0 0             mode,
	create kDisplay_1280x720_120Hz         14850000  547  1280   720  1280  1390  1430  1650    720   725   730   750  P  P  false  false  0 0             mode,
	create kDisplay_720x480_120Hz           5400000  548   720   480   720   736   798   858    480   489   495   525  N  N  false  false  0 0             mode,
	create kDisplay_1440x480i_120Hz         5400000  550  1440   480  1440  1478  1602  1716    480   484   487   503  N  N  true   false  0 0             mode,
	create kDisplay_720x576_200Hz          10800000  552   720   576   720   732   796   864    576   581   586   625  N  N  false  false  0 0             mode,
	create kDisplay_1440x576i_200Hz        10800000  554  1440   576  1440  1464  1590  1728    576   578   581   601  N  N  true   false  0 0             mode,
	create kDisplay_720x480_240Hz          10800000  556   720   480   720   736   798   858    480   489   495   525  N  N  false  false  0 0             mode,
	create kDisplay_1440x480i_240Hz        10800000  558  1440   480  1440  1478  1602  1716    480   484   487   503  N  N  true   false  0 0             mode,
	create kDisplay_1280x720_24Hz           5940000  560  1280   720  1280  3040  3080  3300    720   725   730   750  P  P  false  false  0 0             mode,
	create kDisplay_1280x720_25Hz           7425000  561  1280   720  1280  3700  3740  3960    720   725   730   750  P  P  false  false  0 0             mode,
	create kDisplay_1280x720_30Hz           7425000  562  1280   720  1280  3040  3080  3300    720   725   730   750  P  P  false  false  0 0             mode,
	create kDisplay_1920x1080_120Hz        29700000  563  1920  1080  1920  2008  2052  2200   1080  1084  1089  1125  P  P  false  false  0 0             mode,
	create kDisplay_1920x1080_100Hz        29700000  564  1920  1080  1920  2448  2492  2640   1080  1084  1089  1125  P  P  false  false  0 0             mode,
	create kDisplay_1680x720_24Hz           5940000  579  1680   720  1680  3040  3080  3300    720   725   730   750  P  P  false  false  0 0             mode,
	create kDisplay_1680x720_25Hz           5940000  580  1680   720  1680  2908  2948  3168    720   725   730   750  P  P  false  false  0 0             mode,
	create kDisplay_1680x720_30Hz           5940000  581  1680   720  1680  2380  2420  2640    720   725   730   750  P  P  false  false  0 0             mode,
	create kDisplay_1680x720_50Hz           8250000  582  1680   720  1680  1940  1980  2200    720   725   730   750  P  P  false  false  0 0             mode,
	create kDisplay_1680x720_60Hz           9900000  583  1680   720  1680  1940  1980  2200    720   725   730   750  P  P  false  false  0 0             mode,
	create kDisplay_1680x720_100Hz         16500000  584  1680   720  1680  1740  1780  2000    720   725   730   825  P  P  false  false  0 0             mode,
	create kDisplay_1680x720_120Hz         19800000  585  1680   720  1680  1740  1780  2000    720   725   730   825  P  P  false  false  0 0             mode,
	create kDisplay_2560x1080_24Hz          9900000  586  2560  1080  2560  3558  3602  3750   1080  1084  1089  1100  P  P  false  false  0 0             mode,
	create kDisplay_2560x1080_25Hz          9000000  587  2560  1080  2560  3008  3052  3200   1080  1084  1089  1125  P  P  false  false  0 0             mode,
	create kDisplay_2560x1080_30Hz         11880000  588  2560  1080  2560  3328  3372  3520   1080  1084  1089  1125  P  P  false  false  0 0             mode,
	create kDisplay_2560x1080_50Hz         18562500  589  2560  1080  2560  3108  3152  3300   1080  1084  1089  1125  P  P  false  false  0 0             mode,
	create kDisplay_2560x1080_60Hz         19800000  590  2560  1080  2560  2808  2852  3000   1080  1084  1089  1100  P  P  false  false  0 0             mode,
	create kDisplay_2560x1080_100Hz        37125000  591  2560  1080  2560  2778  2822  2970   1080  1084  1089  1250  P  P  false  false  0 0             mode,
	create kDisplay_2560x1080_120Hz        49500000  592  2560  1080  2560  3108  3152  3300   1080  1084  1089  1250  P  P  false  false  0 0             mode,
	create kDisplay_3840x2160_24Hz         29700000  593  3840  2160  3840  5116  5204  5500   2160  2168  2178  2250  P  P  false  false  0 0             mode,
	create kDisplay_3840x2160_25Hz         29700000  594  3840  2160  3840  4896  4984  5280   2160  2168  2178  2250  P  P  false  false  0 0             mode,
	create kDisplay_3840x2160_30Hz         29700000  595  3840  2160  3840  4016  4104  4400   2160  2168  2178  2250  P  P  false  false  0 0             mode,
	create kDisplay_3840x2160_50Hz         59400000  596  3840  2160  3840  4896  4984  5280   2160  2168  2178  2250  P  P  false  false  0 0             mode,
	create kDisplay_3840x2160_60Hz         59400000  597  3840  2160  3840  4016  4104  4400   2160  2168  2178  2250  P  P  false  false  0 0             mode,
	create kDisplay_4096x2160_24Hz         29700000  598  4096  2160  4096  5116  5204  5500   2160  2168  2178  2250  P  P  false  false  0 0             mode,
	create kDisplay_4096x2160_25Hz         29700000  599  4096  2160  4096  5064  5152  5280   2160  2168  2178  2250  P  P  false  false  0 0             mode,
	create kDisplay_4096x2160_30Hz         29700000  600  4096  2160  4096  4184  4272  4400   2160  2168  2178  2250  P  P  false  false  0 0             mode,
	create kDisplay_4096x2160_50Hz         59400000  601  4096  2160  4096  5064  5152  5280   2160  2168  2178  2250  P  P  false  false  0 0             mode,
	create kDisplay_4096x2160_60Hz         59400000  602  4096  2160  4096  4184  4272  4400   2160  2168  2178  2250  P  P  false  false  0 0             mode,
	create kDisplay_1280x720_48Hz           9000000  608  1280   720  1280  2240  2280  2500    720   725   730   750  P  P  false  false  0 0             mode,
	create kDisplay_1680x720_48Hz           9900000  610  1680   720  1680  2490  2530  2750    720   725   730   750  P  P  false  false  0 0             mode,
	create kDisplay_1920x1080_48Hz         14850000  611  1920  1080  1920  2558  2602  2750   1080  1084  1089  1125  P  P  false  false  0 0             mode,
	create kDisplay_2560x1080_48Hz         19800000  613  2560  1080  2560  3558  3602  3750   1080  1084  1089  1100  P  P  false  false  0 0             mode,
	create kDisplay_3840x2160_48Hz         59400000  614  3840  2160  3840  5116  5204  5500   2160  2168  2178  2250  P  P  false  false  0 0             mode,
	create kDisplay_4096x2160_48Hz         59400000  615  4096  2160  4096  5116  5204  5500   2160  2168  2178  2250  P  P  false  false  0 0             mode,
	create kDisplay_3840x2160_100Hz       118800000  617  3840  2160  3840  4896  4984  5280   2160  2168  2178  2250  P  P  false  false  0 0             mode,
	create kDisplay_3840x2160_120Hz       118800000  618  3840  2160  3840  4016  4104  4400   2160  2168  2178  2250  P  P  false  false  0 0             mode,
	create kDisplay_5120x2160_24Hz         39600000  621  5120  2160  5120  7116  7204  7500   2160  2168  2178  2200  P  P  false  false  0 0             mode,
	create kDisplay_5120x2160_25Hz         39600000  622  5120  2160  5120  6816  6904  7200   2160  2168  2178  2200  P  P  false  false  0 0             mode,
	create kDisplay_5120x2160_30Hz         39600000  623  5120  2160  5120  5784  5872  6000   2160  2168  2178  2200  P  P  false  false  0 0             mode,
	create kDisplay_5120x2160_48Hz         74250000  624  5120  2160  5120  5866  5954  6250   2160  2168  2178  2475  P  P  false  false  0 0             mode,
	create kDisplay_5120x2160_50Hz         74250000  625  5120  2160  5120  6216  6304  6600   2160  2168  2178  2250  P  P  false  false  0 0             mode,
	create kDisplay_5120x2160_60Hz         74250000  626  5120  2160  5120  5284  5372  5500   2160  2168  2178  2250  P  P  false  false  0 0             mode,
	create kDisplay_5120x2160_100Hz       148500000  627  5120  2160  5120  6216  6304  6600   2160  2168  2178  2250  P  P  false  false  0 0             mode,
	create kDisplay_5120x2160_120Hz       148500000  628  5120  2160  5120  5284  5372  5500   2160  2168  2178  2250  P  P  false  false  0 0             mode,
	create kDisplay_7680x4320_24Hz        118800000  629  7680  4320  7680 10232 10408 11000   4320  4336  4356  4500  P  P  false  false  0 0             mode,
	create kDisplay_7680x4320_25Hz        118800000  630  7680  4320  7680 10032 10208 10800   4320  4336  4356  4400  P  P  false  false  0 0             mode,
	create kDisplay_7680x4320_30Hz        118800000  631  7680  4320  7680  8232  8408  9000   4320  4336  4356  4400  P  P  false  false  0 0             mode,
	create kDisplay_7680x4320_48Hz        237600000  632  7680  4320  7680 10232 10408 11000   4320  4336  4356  4500  P  P  false  false  0 0             mode,
	create kDisplay_7680x4320_50Hz        237600000  633  7680  4320  7680 10032 10208 10800   4320  4336  4356  4400  P  P  false  false  0 0             mode,
	create kDisplay_7680x4320_60Hz        237600000  634  7680  4320  7680  8232  8408  9000   4320  4336  4356  4400  P  P  false  false  0 0             mode,
	create kDisplay_7680x4320_100Hz       475200000  635  7680  4320  7680  9792  9968 10560   4320  4336  4356  4500  P  P  false  false  0 0             mode,
	create kDisplay_7680x4320_120Hz       475200000  636  7680  4320  7680  8032  8208  8800   4320  4336  4356  4500  P  P  false  false  0 0             mode,
	create kDisplay_10240x4320_24Hz       148500000  645 10240  4320 10240 11732 11908 12500   4320  4336  4356  4950  P  P  false  false  0 0             mode,
	create kDisplay_10240x4320_25Hz       148500000  646 10240  4320 10240 12732 12908 13500   4320  4336  4356  4400  P  P  false  false  0 0             mode,
	create kDisplay_10240x4320_30Hz       148500000  647 10240  4320 10240 10528 10704 11000   4320  4336  4356  4500  P  P  false  false  0 0             mode,
	create kDisplay_10240x4320_48Hz       297000000  648 10240  4320 10240 11732 11908 12500   4320  4336  4356  4950  P  P  false  false  0 0             mode,
	create kDisplay_10240x4320_50Hz       297000000  649 10240  4320 10240 12732 12908 13500   4320  4336  4356  4400  P  P  false  false  0 0             mode,
	create kDisplay_10240x4320_60Hz       297000000  650 10240  4320 10240 10528 10704 11000   4320  4336  4356  4500  P  P  false  false  0 0             mode,
	create kDisplay_10240x4320_100Hz      594000000  651 10240  4320 10240 12432 12608 13200   4320  4336  4356  4500  P  P  false  false  0 0             mode,
	create kDisplay_10240x4320_120Hz      594000000  652 10240  4320 10240 10528 10704 11000   4320  4336  4356  4500  P  P  false  false  0 0             mode,
	create kDisplay_4096x2160_100Hz       118800000  653  4096  2160  4096  4896  4984  5280   2160  2168  2178  2250  P  P  false  false  0 0             mode,
	create kDisplay_4096x2160_120Hz       118800000  654  4096  2160  4096  4184  4272  4400   2160  2168  2178  2250  P  P  false  false  0 0             mode,

	" ] timings" .dbg cr
	" [ all-display-timings" .dbg cr

	create all-display-timings
		kDisplay_640x480i_60Hz_NTSC    l,
		kDisplay_512x342_60Hz          l,
		kDisplay_512x384_60Hz          l,
		kDisplay_560x384_60Hz          l,
		kDisplay_640x400_67Hz          l,
		kDisplay_640x870_75Hz          l,
		kDisplay_1024x768_75Hz         l,
		kDisplay_1280x960_75Hz         l,
		kDisplay_720x400_70Hz          l,
		kDisplay_720x400_88Hz          l,
		kDisplay_640x480_67Hz          l,
		kDisplay_832x624_75Hz          l,
		kDisplay_1152x870_75Hz         l,
		kDisplay_640x350_85Hz          l,
		kDisplay_640x400_85Hz          l,
		kDisplay_720x400_85Hz          l,
		kDisplay_640x480_60Hz_VGA      l,
		kDisplay_640x480_72Hz          l,
		kDisplay_640x480_75Hz          l,
		kDisplay_640x480_85Hz          l,
		kDisplay_800x600_56Hz_VGA      l,
		kDisplay_800x600_60Hz_VGA      l,
		kDisplay_800x600_72Hz_VGA      l,
		kDisplay_800x600_75Hz_VGA      l,
		kDisplay_800x600_85Hz          l,
		kDisplay_800x600_120Hz         l,
		kDisplay_848x480_60Hz          l,
		kDisplay_1024x768i_87Hz        l,
		kDisplay_1024x768_60Hz_VGA     l,
		kDisplay_1024x768_70Hz         l,
		kDisplay_1024x768_75Hz_VGA     l,
		kDisplay_1024x768_85Hz         l,
		kDisplay_1024x768_120Hz        l,
		kDisplay_1152x864_75Hz         l,
		kDisplay_1280x720_60Hz         l,
		kDisplay_1280x768_60Hz_RB      l,
		kDisplay_1280x768_59_87Hz      l,
		kDisplay_1280x768_75Hz         l,
		kDisplay_1280x768_85Hz         l,
		kDisplay_1280x768_120Hz        l,
		kDisplay_1280x800_60Hz_RB      l,
		kDisplay_1280x800_60Hz         l,
		kDisplay_1280x800_75Hz         l,
		kDisplay_1280x800_85Hz         l,
		kDisplay_1280x800_120Hz        l,
		kDisplay_1280x960_60Hz         l,
		kDisplay_1280x960_85Hz         l,
		kDisplay_1280x960_120Hz        l,
		kDisplay_1280x1024_60Hz        l,
		kDisplay_1280x1024_75Hz        l,
		kDisplay_1280x1024_85Hz        l,
		kDisplay_1280x1024_120Hz       l,
		kDisplay_1360x768_60Hz         l,
		kDisplay_1360x768_120Hz        l,
		kDisplay_1366x768_60Hz         l,
		kDisplay_1366x768_60Hz_RB      l,
		kDisplay_1400x1050_60Hz_RB     l,
		kDisplay_1400x1050_60Hz        l,
		kDisplay_1400x1050_75Hz        l,
		kDisplay_1400x1050_85Hz        l,
		kDisplay_1400x1050_120Hz       l,
		kDisplay_1440x900_60Hz_RB      l,
		kDisplay_1440x900_60Hz         l,
		kDisplay_1440x900_75Hz         l,
		kDisplay_1440x900_85Hz         l,
		kDisplay_1440x900_120Hz        l,
		kDisplay_1600x900_60Hz         l,
		kDisplay_1600x1200_60Hz        l,
		kDisplay_1600x1200_65Hz        l,
		kDisplay_1600x1200_70Hz        l,
		kDisplay_1600x1200_75Hz        l,
		kDisplay_1600x1200_85Hz        l,
		kDisplay_1600x1200_120Hz       l,
		kDisplay_1680x1050_60Hz_RB     l,
		kDisplay_1680x1050_60Hz        l,
		kDisplay_1680x1050_75Hz        l,
		kDisplay_1680x1050_85Hz        l,
		kDisplay_1680x1050_120Hz       l,
		kDisplay_1792x1344_60Hz        l,
		kDisplay_1792x1344_75Hz        l,
		kDisplay_1792x1344_120Hz       l,
		kDisplay_1856x1392_60Hz        l,
		kDisplay_1856x1392_75Hz        l,
		kDisplay_1856x1392_120Hz       l,
		kDisplay_1920x1080_60Hz        l,
		kDisplay_1920x1200_60Hz_RB     l,
		kDisplay_1920x1200_60Hz        l,
		kDisplay_1920x1200_75Hz        l,
		kDisplay_1920x1200_85Hz        l,
		kDisplay_1920x1200_120Hz       l,
		kDisplay_1920x1440_60Hz        l,
		kDisplay_1920x1440_75Hz        l,
		kDisplay_1920x1440_120Hz       l,
		kDisplay_2048x1152_60Hz        l,
		kDisplay_2560x1600_60Hz_RB     l,
		kDisplay_2560x1600_60Hz        l,
		kDisplay_2560x1600_75Hz        l,
		kDisplay_2560x1600_85Hz        l,
		kDisplay_2560x1600_120Hz       l,
		kDisplay_4096x2160_60Hz_RB     l,
		kDisplay_4096x2160_59_94Hz     l,
		kDisplay_720x480_60Hz          l,
		kDisplay_1920x1080i_60Hz       l,
		kDisplay_1440x480i_60Hz        l,
		kDisplay_1440x240_60Hz         l,
		kDisplay_2880x480i_60Hz        l,
		kDisplay_2880x240_60Hz         l,
		kDisplay_1440x480_60Hz         l,
		kDisplay_720x576_50Hz          l,
		kDisplay_1280x720_50Hz         l,
		kDisplay_1920x1080i_50Hz       l,
		kDisplay_1440x576i_50Hz        l,
		kDisplay_1440x288_50Hz         l,
		kDisplay_2880x576i_50Hz        l,
		kDisplay_2880x288_50Hz         l,
		kDisplay_1440x576_50Hz         l,
		kDisplay_1920x1080_50Hz        l,
		kDisplay_1920x1080_24Hz        l,
		kDisplay_1920x1080_25Hz        l,
		kDisplay_1920x1080_30Hz        l,
		kDisplay_2880x480_60Hz         l,
		kDisplay_2880x576_50Hz         l,
		kDisplay_1920x1080i_50Hz_72MHz l,
		kDisplay_1920x1080i_100Hz      l,
		kDisplay_1280x720_100Hz        l,
		kDisplay_720x576_100Hz         l,
		kDisplay_1440x576i_100Hz       l,
		kDisplay_1920x1080i_120Hz      l,
		kDisplay_1280x720_120Hz        l,
		kDisplay_720x480_120Hz         l,
		kDisplay_1440x480i_120Hz       l,
		kDisplay_720x576_200Hz         l,
		kDisplay_1440x576i_200Hz       l,
		kDisplay_720x480_240Hz         l,
		kDisplay_1440x480i_240Hz       l,
		kDisplay_1280x720_24Hz         l,
		kDisplay_1280x720_25Hz         l,
		kDisplay_1280x720_30Hz         l,
		kDisplay_1920x1080_120Hz       l,
		kDisplay_1920x1080_100Hz       l,
		kDisplay_1680x720_24Hz         l,
		kDisplay_1680x720_25Hz         l,
		kDisplay_1680x720_30Hz         l,
		kDisplay_1680x720_50Hz         l,
		kDisplay_1680x720_60Hz         l,
		kDisplay_1680x720_100Hz        l,
		kDisplay_1680x720_120Hz        l,
		kDisplay_2560x1080_24Hz        l,
		kDisplay_2560x1080_25Hz        l,
		kDisplay_2560x1080_30Hz        l,
		kDisplay_2560x1080_50Hz        l,
		kDisplay_2560x1080_60Hz        l,
		kDisplay_2560x1080_100Hz       l,
		kDisplay_2560x1080_120Hz       l,
		kDisplay_3840x2160_24Hz        l,
		kDisplay_3840x2160_25Hz        l,
		kDisplay_3840x2160_30Hz        l,
		kDisplay_3840x2160_50Hz        l,
		kDisplay_3840x2160_60Hz        l,
		kDisplay_4096x2160_24Hz        l,
		kDisplay_4096x2160_25Hz        l,
		kDisplay_4096x2160_30Hz        l,
		kDisplay_4096x2160_50Hz        l,
		kDisplay_4096x2160_60Hz        l,
		kDisplay_1280x720_48Hz         l,
		kDisplay_1680x720_48Hz         l,
		kDisplay_1920x1080_48Hz        l,
		kDisplay_2560x1080_48Hz        l,
		kDisplay_3840x2160_48Hz        l,
		kDisplay_4096x2160_48Hz        l,
		kDisplay_3840x2160_100Hz       l,
		kDisplay_3840x2160_120Hz       l,
		kDisplay_5120x2160_24Hz        l,
		kDisplay_5120x2160_25Hz        l,
		kDisplay_5120x2160_30Hz        l,
		kDisplay_5120x2160_48Hz        l,
		kDisplay_5120x2160_50Hz        l,
		kDisplay_5120x2160_60Hz        l,
		kDisplay_5120x2160_100Hz       l,
		kDisplay_5120x2160_120Hz       l,
		kDisplay_7680x4320_24Hz        l,
		kDisplay_7680x4320_25Hz        l,
		kDisplay_7680x4320_30Hz        l,
		kDisplay_7680x4320_48Hz        l,
		kDisplay_7680x4320_50Hz        l,
		kDisplay_7680x4320_60Hz        l,
		kDisplay_7680x4320_100Hz       l,
		kDisplay_7680x4320_120Hz       l,
		kDisplay_10240x4320_24Hz       l,
		kDisplay_10240x4320_25Hz       l,
		kDisplay_10240x4320_30Hz       l,
		kDisplay_10240x4320_48Hz       l,
		kDisplay_10240x4320_50Hz       l,
		kDisplay_10240x4320_60Hz       l,
		kDisplay_10240x4320_100Hz      l,
		kDisplay_10240x4320_120Hz      l,
		kDisplay_4096x2160_100Hz       l,
		kDisplay_4096x2160_120Hz       l,
		0 l,

	" ] all-display-timings" .dbg cr
	" [ established-timings-i-and-ii" .dbg cr

	create established-timings-i-and-ii
		kDisplay_720x400_70Hz          l,
		kDisplay_720x400_88Hz          l,
		kDisplay_640x480_60Hz_VGA      l,
		kDisplay_640x480_67Hz          l,
		kDisplay_640x480_72Hz          l,
		kDisplay_640x480_75Hz          l,
		kDisplay_800x600_56Hz_VGA      l,
		kDisplay_800x600_60Hz_VGA      l,
		kDisplay_800x600_72Hz_VGA      l,
		kDisplay_800x600_75Hz_VGA      l,
		kDisplay_832x624_75Hz          l,
		kDisplay_1024x768i_87Hz        l,
		kDisplay_1024x768_60Hz_VGA     l,
		kDisplay_1024x768_70Hz         l,
		kDisplay_1024x768_75Hz_VGA     l,
		kDisplay_1280x1024_75Hz        l,
		kDisplay_1152x870_75Hz         l,
		0 l,

	" ] established-timings-i-and-ii" .dbg cr
	" [ established-timings-iii" .dbg cr

	create established-timings-iii
		kDisplay_640x350_85Hz          l,
		kDisplay_640x400_85Hz          l,
		kDisplay_720x400_85Hz          l,
		kDisplay_640x480_85Hz          l,
		kDisplay_848x480_60Hz          l,
		kDisplay_800x600_85Hz          l,
		kDisplay_1024x768_85Hz         l,
		kDisplay_1152x864_75Hz         l,
		kDisplay_1280x768_60Hz_RB      l,
		kDisplay_1280x768_59_87Hz      l,
		kDisplay_1280x768_75Hz         l,
		kDisplay_1280x768_85Hz         l,
		kDisplay_1280x960_60Hz         l,
		kDisplay_1280x960_85Hz         l,
		kDisplay_1280x1024_60Hz        l,
		kDisplay_1280x1024_85Hz        l,
		kDisplay_1360x768_60Hz         l,
		kDisplay_1440x900_60Hz_RB      l,
		kDisplay_1440x900_60Hz         l,
		kDisplay_1440x900_75Hz         l,
		kDisplay_1440x900_85Hz         l,
		kDisplay_1400x1050_60Hz_RB     l,
		kDisplay_1400x1050_60Hz        l,
		kDisplay_1400x1050_75Hz        l,
		kDisplay_1400x1050_85Hz        l,
		kDisplay_1680x1050_60Hz_RB     l,
		kDisplay_1680x1050_60Hz        l,
		kDisplay_1680x1050_75Hz        l,
		kDisplay_1680x1050_85Hz        l,
		kDisplay_1600x1200_60Hz        l,
		kDisplay_1600x1200_65Hz        l,
		kDisplay_1600x1200_70Hz        l,
		kDisplay_1600x1200_75Hz        l,
		kDisplay_1600x1200_85Hz        l,
		kDisplay_1792x1344_60Hz        l,
		kDisplay_1792x1344_75Hz        l,
		kDisplay_1856x1392_60Hz        l,
		kDisplay_1856x1392_75Hz        l,
		kDisplay_1920x1200_60Hz_RB     l,
		kDisplay_1920x1200_60Hz        l,
		kDisplay_1920x1200_75Hz        l,
		kDisplay_1920x1200_85Hz        l,
		kDisplay_1920x1440_60Hz        l,
		kDisplay_1920x1440_75Hz        l,
		0 l,

	: dmt, l, l, ;
	create dmt-display-monitor-timings
		kDisplay_640x350_85Hz          h# 0000 dmt,
		kDisplay_640x400_85Hz          h# 3119 dmt,
		kDisplay_720x400_85Hz          h# 0000 dmt,
		kDisplay_640x480_60Hz_VGA      h# 3140 dmt,
		kDisplay_640x480_72Hz          h# 314c dmt,
		kDisplay_640x480_75Hz          h# 314f dmt,
		kDisplay_640x480_85Hz          h# 3159 dmt,
		kDisplay_800x600_56Hz_VGA      h# 0000 dmt,
		kDisplay_800x600_60Hz_VGA      h# 4540 dmt,
		kDisplay_800x600_72Hz_VGA      h# 454c dmt,
		kDisplay_800x600_75Hz_VGA      h# 454f dmt,
		kDisplay_800x600_85Hz          h# 4559 dmt,
		kDisplay_800x600_120Hz         h# 0000 dmt,
		kDisplay_848x480_60Hz          h# 0000 dmt,
		kDisplay_1024x768i_87Hz        h# 0000 dmt,
		kDisplay_1024x768_60Hz_VGA     h# 6140 dmt,
		kDisplay_1024x768_70Hz         h# 614c dmt,
		kDisplay_1024x768_75Hz_VGA     h# 614f dmt,
		kDisplay_1024x768_85Hz         h# 6159 dmt,
		kDisplay_1024x768_120Hz        h# 0000 dmt,
		kDisplay_1152x864_75Hz         h# 714f dmt,
		kDisplay_1280x720_60Hz         h# 0000 dmt,
		kDisplay_1280x768_60Hz_RB      h# 0000 dmt,
		kDisplay_1280x768_59_87Hz      h# 0000 dmt,
		kDisplay_1280x768_75Hz         h# 0000 dmt,
		kDisplay_1280x768_85Hz         h# 0000 dmt,
		kDisplay_1280x768_120Hz        h# 0000 dmt,
		kDisplay_1280x800_60Hz_RB      h# 8100 dmt,
		kDisplay_1280x800_60Hz         h# 810f dmt,
		kDisplay_1280x800_75Hz         h# 8119 dmt,
		kDisplay_1280x800_85Hz         h# 0000 dmt,
		kDisplay_1280x800_120Hz        h# 8140 dmt,
		kDisplay_1280x960_60Hz         h# 8159 dmt,
		kDisplay_1280x960_85Hz         h# 0000 dmt,
		kDisplay_1280x960_120Hz        h# 8180 dmt,
		kDisplay_1280x1024_60Hz        h# 818f dmt,
		kDisplay_1280x1024_75Hz        h# 8199 dmt,
		kDisplay_1280x1024_85Hz        h# 0000 dmt,
		kDisplay_1280x1024_120Hz       h# 0000 dmt,
		kDisplay_1360x768_60Hz         h# 0000 dmt,
		kDisplay_1360x768_120Hz        h# 0000 dmt,
		kDisplay_1366x768_60Hz         h# 9040 dmt,
		kDisplay_1366x768_60Hz_RB      h# 904f dmt,
		kDisplay_1400x1050_60Hz_RB     h# 9059 dmt,
		kDisplay_1400x1050_60Hz        h# 0000 dmt,
		kDisplay_1400x1050_75Hz        h# 0000 dmt,
		kDisplay_1400x1050_85Hz        h# 9500 dmt,
		kDisplay_1400x1050_120Hz       h# 950f dmt,
		kDisplay_1440x900_60Hz_RB      h# 9519 dmt,
		kDisplay_1440x900_60Hz         h# 0000 dmt,
		kDisplay_1440x900_75Hz         h# a940 dmt,
		kDisplay_1440x900_85Hz         h# a945 dmt,
		kDisplay_1440x900_120Hz        h# a94a dmt,
		kDisplay_1600x900_60Hz         h# a94f dmt,
		kDisplay_1600x1200_60Hz        h# a959 dmt,
		kDisplay_1600x1200_65Hz        h# 0000 dmt,
		kDisplay_1600x1200_70Hz        h# 0000 dmt,
		kDisplay_1600x1200_75Hz        h# b300 dmt,
		kDisplay_1600x1200_85Hz        h# b30f dmt,
		kDisplay_1600x1200_120Hz       h# b319 dmt,
		kDisplay_1680x1050_60Hz_RB     h# 0000 dmt,
		kDisplay_1680x1050_60Hz        h# c140 dmt,
		kDisplay_1680x1050_75Hz        h# c14f dmt,
		kDisplay_1680x1050_85Hz        h# 0000 dmt,
		kDisplay_1680x1050_120Hz       h# c940 dmt,
		kDisplay_1792x1344_60Hz        h# c94f dmt,
		kDisplay_1792x1344_75Hz        h# 0000 dmt,
		kDisplay_1792x1344_120Hz       h# 0000 dmt,
		kDisplay_1856x1392_60Hz        h# d100 dmt,
		kDisplay_1856x1392_75Hz        h# d10f dmt,
		kDisplay_1856x1392_120Hz       h# d119 dmt,
		kDisplay_1920x1080_60Hz        h# 0000 dmt,
		kDisplay_1920x1200_60Hz_RB     h# d140 dmt,
		kDisplay_1920x1200_60Hz        h# d14f dmt,
		kDisplay_1920x1200_75Hz        h# 0000 dmt,
		kDisplay_1920x1200_85Hz        h# 0000 dmt,
		kDisplay_1920x1200_120Hz       h# 0000 dmt,
		kDisplay_1920x1440_60Hz        h# 0000 dmt,
		kDisplay_1920x1440_75Hz        h# 0000 dmt,
		kDisplay_1920x1440_120Hz       h# 0000 dmt,
		kDisplay_2048x1152_60Hz        h# 0000 dmt,
		kDisplay_2560x1600_60Hz_RB     h# d1c0 dmt,
		kDisplay_2560x1600_60Hz        h# a9c0 dmt,
		kDisplay_2560x1600_75Hz        h# e1c0 dmt,
		kDisplay_2560x1600_85Hz        h# 81c0 dmt,
		kDisplay_2560x1600_120Hz       h# 0000 dmt,
		kDisplay_4096x2160_60Hz_RB     h# 0000 dmt,
		kDisplay_4096x2160_59_94Hz     h# 0000 dmt,
	here dmt-display-monitor-timings - /dmt-entry / constant dmt-count

	" ] established-timings-iii" .dbg cr
	" [ vic-timings" .dbg cr

	: vic, l, l, ;
	create vic-timings
		kDisplay_640x480_60Hz_VGA        1  vic,
		kDisplay_720x480_60Hz            2  vic,
		kDisplay_720x480_60Hz            3  vic,
		kDisplay_1280x720_60Hz           4  vic,
		kDisplay_1920x1080i_60Hz         5  vic,
		kDisplay_1440x480i_60Hz          6  vic,
		kDisplay_1440x480i_60Hz          7  vic,
		kDisplay_1440x240_60Hz           8  vic,
		kDisplay_1440x240_60Hz           9  vic,
		kDisplay_2880x480i_60Hz         10  vic,
		kDisplay_2880x480i_60Hz         11  vic,
		kDisplay_2880x240_60Hz          12  vic,
		kDisplay_2880x240_60Hz          13  vic,
		kDisplay_1440x480_60Hz          14  vic,
		kDisplay_1440x480_60Hz          15  vic,
		kDisplay_1920x1080_60Hz         16  vic,
		kDisplay_720x576_50Hz           17  vic,
		kDisplay_720x576_50Hz           18  vic,
		kDisplay_1280x720_50Hz          19  vic,
		kDisplay_1920x1080i_50Hz        20  vic,
		kDisplay_1440x576i_50Hz         21  vic,
		kDisplay_1440x576i_50Hz         22  vic,
		kDisplay_1440x288_50Hz          23  vic,
		kDisplay_1440x288_50Hz          24  vic,
		kDisplay_2880x576i_50Hz         25  vic,
		kDisplay_2880x576i_50Hz         26  vic,
		kDisplay_2880x288_50Hz          27  vic,
		kDisplay_2880x288_50Hz          28  vic,
		kDisplay_1440x576_50Hz          29  vic,
		kDisplay_1440x576_50Hz          30  vic,
		kDisplay_1920x1080_50Hz         31  vic,
		kDisplay_1920x1080_24Hz         32  vic,
		kDisplay_1920x1080_25Hz         33  vic,
		kDisplay_1920x1080_30Hz         34  vic,
		kDisplay_2880x480_60Hz          35  vic,
		kDisplay_2880x480_60Hz          36  vic,
		kDisplay_2880x576_50Hz          37  vic,
		kDisplay_2880x576_50Hz          38  vic,
		kDisplay_1920x1080i_50Hz_72MHz  39  vic,
		kDisplay_1920x1080i_100Hz       40  vic,
		kDisplay_1280x720_100Hz         41  vic,
		kDisplay_720x576_100Hz          42  vic,
		kDisplay_720x576_100Hz          43  vic,
		kDisplay_1440x576i_100Hz        44  vic,
		kDisplay_1440x576i_100Hz        45  vic,
		kDisplay_1920x1080i_120Hz       46  vic,
		kDisplay_1280x720_120Hz         47  vic,
		kDisplay_720x480_120Hz          48  vic,
		kDisplay_720x480_120Hz          49  vic,
		kDisplay_1440x480i_120Hz        50  vic,
		kDisplay_1440x480i_120Hz        51  vic,
		kDisplay_720x576_200Hz          52  vic,
		kDisplay_720x576_200Hz          53  vic,
		kDisplay_1440x576i_200Hz        54  vic,
		kDisplay_1440x576i_200Hz        55  vic,
		kDisplay_720x480_240Hz          56  vic,
		kDisplay_720x480_240Hz          57  vic,
		kDisplay_1440x480i_240Hz        58  vic,
		kDisplay_1440x480i_240Hz        59  vic,
		kDisplay_1280x720_24Hz          60  vic,
		kDisplay_1280x720_25Hz          61  vic,
		kDisplay_1280x720_30Hz          62  vic,
		kDisplay_1920x1080_120Hz        63  vic,
		kDisplay_1920x1080_100Hz        64  vic,
		kDisplay_1280x720_24Hz          65  vic,
		kDisplay_1280x720_25Hz          66  vic,
		kDisplay_1280x720_30Hz          67  vic,
		kDisplay_1280x720_50Hz          68  vic,
		kDisplay_1280x720_60Hz          69  vic,
		kDisplay_1280x720_100Hz         70  vic,
		kDisplay_1280x720_120Hz         71  vic,
		kDisplay_1920x1080_24Hz         72  vic,
		kDisplay_1920x1080_25Hz         73  vic,
		kDisplay_1920x1080_30Hz         74  vic,
		kDisplay_1920x1080_50Hz         75  vic,
		kDisplay_1920x1080_60Hz         76  vic,
		kDisplay_1920x1080_100Hz        77  vic,
		kDisplay_1920x1080_120Hz        78  vic,
		kDisplay_1680x720_24Hz          79  vic,
		kDisplay_1680x720_25Hz          80  vic,
		kDisplay_1680x720_30Hz          81  vic,
		kDisplay_1680x720_50Hz          82  vic,
		kDisplay_1680x720_60Hz          83  vic,
		kDisplay_1680x720_100Hz         84  vic,
		kDisplay_1680x720_120Hz         85  vic,
		kDisplay_2560x1080_24Hz         86  vic,
		kDisplay_2560x1080_25Hz         87  vic,
		kDisplay_2560x1080_30Hz         88  vic,
		kDisplay_2560x1080_50Hz         89  vic,
		kDisplay_2560x1080_60Hz         90  vic,
		kDisplay_2560x1080_100Hz        91  vic,
		kDisplay_2560x1080_120Hz        92  vic,
		kDisplay_3840x2160_24Hz         93  vic,
		kDisplay_3840x2160_25Hz         94  vic,
		kDisplay_3840x2160_30Hz         95  vic,
		kDisplay_3840x2160_50Hz         96  vic,
		kDisplay_3840x2160_60Hz         97  vic,
		kDisplay_4096x2160_24Hz         98  vic,
		kDisplay_4096x2160_25Hz         99  vic,
		kDisplay_4096x2160_30Hz        100  vic,
		kDisplay_4096x2160_50Hz        101  vic,
		kDisplay_4096x2160_60Hz        102  vic,
		kDisplay_3840x2160_24Hz        103  vic,
		kDisplay_3840x2160_25Hz        104  vic,
		kDisplay_3840x2160_30Hz        105  vic,
		kDisplay_3840x2160_50Hz        106  vic,
		kDisplay_3840x2160_60Hz        107  vic,
		kDisplay_1280x720_48Hz         108  vic,
		kDisplay_1280x720_48Hz         109  vic,
		kDisplay_1680x720_48Hz         110  vic,
		kDisplay_1920x1080_48Hz        111  vic,
		kDisplay_1920x1080_48Hz        112  vic,
		kDisplay_2560x1080_48Hz        113  vic,
		kDisplay_3840x2160_48Hz        114  vic,
		kDisplay_4096x2160_48Hz        115  vic,
		kDisplay_3840x2160_48Hz        116  vic,
		kDisplay_3840x2160_100Hz       117  vic,
		kDisplay_3840x2160_120Hz       118  vic,
		kDisplay_3840x2160_100Hz       119  vic,
		kDisplay_3840x2160_120Hz       120  vic,
		kDisplay_5120x2160_24Hz        121  vic,
		kDisplay_5120x2160_25Hz        122  vic,
		kDisplay_5120x2160_30Hz        123  vic,
		kDisplay_5120x2160_48Hz        124  vic,
		kDisplay_5120x2160_50Hz        125  vic,
		kDisplay_5120x2160_60Hz        126  vic,
		kDisplay_5120x2160_100Hz       127  vic,
		kDisplay_5120x2160_120Hz       193  vic,
		kDisplay_7680x4320_24Hz        194  vic,
		kDisplay_7680x4320_25Hz        195  vic,
		kDisplay_7680x4320_30Hz        196  vic,
		kDisplay_7680x4320_48Hz        197  vic,
		kDisplay_7680x4320_50Hz        198  vic,
		kDisplay_7680x4320_60Hz        199  vic,
		kDisplay_7680x4320_100Hz       200  vic,
		kDisplay_7680x4320_120Hz       201  vic,
		kDisplay_7680x4320_24Hz        202  vic,
		kDisplay_7680x4320_25Hz        203  vic,
		kDisplay_7680x4320_30Hz        204  vic,
		kDisplay_7680x4320_48Hz        205  vic,
		kDisplay_7680x4320_50Hz        206  vic,
		kDisplay_7680x4320_60Hz        207  vic,
		kDisplay_7680x4320_100Hz       208  vic,
		kDisplay_7680x4320_120Hz       209  vic,
		kDisplay_10240x4320_24Hz       210  vic,
		kDisplay_10240x4320_25Hz       211  vic,
		kDisplay_10240x4320_30Hz       212  vic,
		kDisplay_10240x4320_48Hz       213  vic,
		kDisplay_10240x4320_50Hz       214  vic,
		kDisplay_10240x4320_60Hz       215  vic,
		kDisplay_10240x4320_100Hz      216  vic,
		kDisplay_10240x4320_120Hz      217  vic,
		kDisplay_4096x2160_100Hz       218  vic,
		kDisplay_4096x2160_120Hz       219  vic,

	" ] vic-timings" .dbg cr
	" [ sense codes" .dbg cr

	hex
	create kSense_MacColor21in
		kDisplay_1152x870_75Hz l,
		0 l,
	create kSense_PortraitGS
		kDisplay_640x870_75Hz l,
		0 l,
	create kSense_MacRGB12in
		kDisplay_512x384_60Hz l,
		0 l,
	create kSense_Radius21in
		kDisplay_1152x870_75Hz l,
		0 l,
	create kSense_Radius21inGS
		kDisplay_1152x870_75Hz l,
		0 l,
	create kSense_TwoPageGS
		kDisplay_1152x870_75Hz l,
		0 l,
	create kSense_NTSC
		kDisplay_512x384i_60Hz_NTSC l,
		kDisplay_640x480i_60Hz_NTSC l,
		0 l,
	create kSense_MacRGB15in
		kDisplay_640x870_75Hz l,
		0 l,
	create kSense_Multiscan15in
		kDisplay_640x480_67Hz l,
		kDisplay_832x624_75Hz l,
		0 l,
	create kSense_Multiscan17in
		kDisplay_640x480_67Hz l,
		kDisplay_832x624_75Hz l,
		kDisplay_1024x768_75Hz l,
		0 l,
	create kSense_Multiscan20in
		kDisplay_640x480_67Hz l,
		kDisplay_640x480_120Hz l,
		kDisplay_832x624_75Hz l,
		kDisplay_1024x768_75Hz l,
		kDisplay_1152x870_75Hz l,
		kDisplay_1280x960_75Hz l,
		kDisplay_1280x1024_75Hz l,
		0 l,
	create kSense_HiRes12-14in
		kDisplay_640x480_67Hz l,
		0 l,
	create kSense_PALEncoder
		kDisplay_640x480i_50Hz_PAL l,
		kDisplay_768x576i_50Hz_PAL l,
		0 l,
	create kSense_NTSCEncoder
		kDisplay_512x384i_60Hz_NTSC l,
		kDisplay_640x480i_60Hz_NTSC l,
		0 l,
	create kSense_VGA-SVGA
		kDisplay_640x480_60Hz_VGA l,
		kDisplay_640x480_120Hz l,
		kDisplay_800x600_60Hz_VGA l,
		kDisplay_800x600_72Hz_VGA l,
		kDisplay_800x600_75Hz_VGA l,
		kDisplay_1024x768_60Hz_VGA l,
		kDisplay_1024x768_70Hz l,
		kDisplay_1024x768_75Hz_VGA l,
		kDisplay_1280x960_75Hz l,
		kDisplay_1280x1024_75Hz l,
		0 l,
	create kSense_MacRGB16in
		kDisplay_832x624_75Hz l,
		0 l,
	create kSense_PAL
		kDisplay_640x480i_50Hz_PAL l,
		kDisplay_768x576i_50Hz_PAL l,
		0 l,
	create kSense_MacRGB19in
		kDisplay_1024x768_75Hz l,
		0 l,
	create kSense_DDC
		0 l,
	create kSense_NotConnected
		0 l,

	" ] sense codes" .dbg cr
	" [ sense-codes-list" .dbg cr

	: sm,
		d# 3 0 do i roll loop w, w, l,
		;

	create sense-codes-list
		000  false  kSense_MacColor21in   sm,
		114  true   kSense_PortraitGS     sm,
		221  false  kSense_MacRGB12in     sm,
		331  false  kSense_Radius21in     sm,
		334  true   kSense_Radius21inGS   sm,
		335  true   kSense_TwoPageGS      sm,
		40A  false  kSense_NTSC           sm,
		51E  false  kSense_MacRGB15in     sm,
		603  false  kSense_Multiscan15in  sm,
		60B  false  kSense_Multiscan17in  sm,
		623  false  kSense_Multiscan20in  sm,
		62B  false  kSense_HiRes12-14in   sm,
		700  false  kSense_PALEncoder     sm,
		714  false  kSense_NTSCEncoder    sm,
		717  false  kSense_VGA-SVGA       sm,
		72D  false  kSense_MacRGB16in     sm,
		730  false  kSense_PAL            sm,
		73A  false  kSense_MacRGB19in     sm,
		73E  false  kSense_DDC            sm,
		73F  false  kSense_NotConnected   sm,
	here sense-codes-list - /sense-code / constant sense-codes-count

	" ] sense-codes-list" .dbg cr

	: get-sense-code-entry ( sense -- sense-code-entry|0 )
		sense-codes-list swap		\ sense-code-entry sense
		sense-codes-count 0 do
			over w@					\ sense-code-entry sense sense-code-entry->sense
			over =					\ sense-code-entry sense (sense-code-entry->sense == sense)
			if						\ sense-code-entry sense
				drop				\ sense-code-entry
				unloop exit			\ sense-code-entry
			then					\ sense-code-entry sense
			swap					\ sense sense-code-entry
			/sense-code +			\ sense (sense-code-entry+=sense-code-size)
			swap					\ sense sense-code-entry
		loop						\ sense sense-code-entry
		2drop 0						\ 0
		;

	: loop-timings-sense-code ( sense display-info -- )
\ ( \ )	" [ loop-timings-sense-code ( sense display-info -- ) sense:0x" .dbg over 3 u.r cr
\ ( \ )	.stack

		swap						\ display_info sense
		get-sense-code-entry		\ display_info entry
\ ( \ )	.stack

		?dup						\ display_info (entry entry | 0)
		if							\ display_info (entry | )
\ ( \ )		" [ got sense entry ( display-info entry )" .dbg dup 8 u.r cr
\ ( \ )		.stack
			>S.display-timing-list	\ display_info @entry->display-timing-list
			l@						\ display_info list
			begin					\ display_info list
				dup l@				\ display_info list display-timing
				?dup				\ display_info list ( display-timing display-timing | display-timing )
			while					\ display_info list ( display-timing | )
\ ( \ )			" [ mode" .dbg cr
				2 pick				\ display_info list display-timing display_info
\ ( \ )			.stack
				timing-proc ( display-timing display-info -- done? ) \ display_info list done?
				if					\ display_info list
					2drop exit		\
				then
\ ( \ )			.stack
				la1+				\ display_info list+=4
\ ( \ )			" ] mode" .dbg cr
			repeat					\ display_info list
			drop					\ display_info
\ ( \ )		" ] loop end" .dbg cr
\ ( \ )		.stack
		then						\ display_info
		drop						\

\ ( \ )	.stack
\ ( \ )	" ] loop-timings-sense-code" .dbg cr
		;

	0 value current-edid-mode-number
	create temp-display-timing
	/display-timing allot

	: store-and-return-timing ( noteaddr notelen csyncdisabled interlaced vpolarity hpolarity vtot vse vsb vactive height htot hse hsb hactive width pixel_freq_10Hz -- temp-display-timing true )
		current-edid-mode-number dup
		temp-display-timing >T.mode				w!
		1+ to current-edid-mode-number

		temp-display-timing >T.pixel-clock		l!

		temp-display-timing >T.width			w!
		temp-display-timing >T.hactive			w!
		temp-display-timing >T.hsyncbegin		w!
		temp-display-timing >T.hsyncend			w!
		temp-display-timing >T.htotal			w!

		temp-display-timing >T.height			w!
		temp-display-timing >T.vactive			w!
		temp-display-timing >T.vsyncbegin		w!
		temp-display-timing >T.vsyncend			w!
		temp-display-timing >T.vtotal			w!

		temp-display-timing >T.hpolarity		c!
		temp-display-timing >T.vpolarity		c!
		temp-display-timing >T.interlaced		c!
		temp-display-timing >T.csyncdisabled	c!

		temp-display-timing >T.note swap move		\ ( noteaddr note notelen -- )

		temp-display-timing true					\ temp-display-timing true
		;

	: p-edid-revision ( display-info -- revision )
		>I.edid l@ dup >edid.version c@ 1 = swap						\ version==1 edid
		>edid.revision c@ and											\ revision=(version==1)?revision:0)
		;

	: p-edid-analog? ( display-info -- analog? )
		dup p-edid-revision 4 < swap									\ revision<4 display-info
		>I.edid l@ >edid.video-input-parameters c@ h# 80 and 0=			\ (revision<4) (edid.video-input-parameters&0x80 == 0)
		or																\ ((revision<4) || (edid.video-input-parameters&0x80 == 0))
		;

	: p-edid-monochrome? ( display-info -- monochrome? )
		dup p-edid-analog? swap											\ analog? display-info
		>I.edid l@ >edid.supported-features c@ h# 18 and 0=				\ analog? (supported.features&0x18 == 0)
		and																\ (analog? && (supported.features&0x18 == 0))
		;

	: p-edid-supports-cvt? ( display-info -- supports_cvt? )
		\ •
		drop false
		;

	: edid-cvt-mode ( hact vact refresh rbv alt rb_h_blank rb_v_blank early_vsync_rqd -- false | timing true )
\		" [ edid-cvt-mode " .dbg 7 pick .d ." x " 6 pick .d ." @ " 5 pick .d ." Hz" cr

		\ works with these ranges:
		\    hact: 1..65536
		\    vact: 1..65536
		\ refresh: 1..1024

\	if (rbv >= RB_CVT_V2)									v_sync = 8;
\	else if ((vact * 4 / 3) == hact)						v_sync = 4;
\	else if ((vact * 16 / 9) == hact)						v_sync = 5;
\	else if ((vact * 16 / 10) == hact)						v_sync = 6;
\	else if (!(vact % 4) && ((vact * 5 / 4) == hact))		v_sync = 7;
\	else if ((vact * 15 / 9) == hact)						v_sync = 7;
\	else                        /* Custom */				v_sync = 10;
\
\	cell_gran = rbv == RB_CVT_V2 ? 1 : 8;
\	h_pixels_rnd = floor(hact / cell_gran) * cell_gran;
\
\	if (rbv == RB_NONE) {
\		h_period_est = ((1000000.0 / refresh) - 550.0) / (vact + 3);
\		v_sync_bp = floor(550.0 / h_period_est) + 1;
\		if (v_sync_bp < v_sync + 7) v_sync_bp = v_sync + 7;
\		v_blank = v_sync_bp + 3;
\		ideal_duty_cycle = 30.0 - (0.3 * h_period_est);												\ ideal_duty_cycle*10/3 = 100.0 - h_period_est;
\		if (ideal_duty_cycle < 20) ideal_duty_cycle = 20;											\ if (ideal_duty_cycle*10/3 < 200/3) ideal_duty_cycle = 200/3;
\		h_blank = floor(h_pixels_rnd * ideal_duty_cycle / (100.0 - ideal_duty_cycle) / 16) * 16;	\ h_blank = floor(h_pixels_rnd * ideal_duty_cycle / (333.3 - ideal_duty_cycle) / 16) * 16;
\		total_pixels = h_pixels_rnd + h_blank;
\		h_sync = floor(total_pixels * 0.01) * 8;
\		pixel_freq = floor((total_pixels / h_period_est) / 0.25) * 0.25;							\ pixel_freq = total_pixels * (vact+vblank) * refresh
\	} else {
\		if (rbv == RB_CVT_V3 && rb_h_blank) {
\			h_blank = rb_h_blank & ~7;
\			if (h_blank < 80)			h_blank = 80;
\			else if (h_blank > 200)		h_blank = 200;
\		} else {
\			h_blank = (rbv == RB_CVT_V1 || (rbv == RB_CVT_V3 && alt)) ? 160 : 80;
\		}
\
\		if (rbv == RB_CVT_V3) {
\			if (rb_v_blank < 300.0)										rb_v_blank = 300.0;
\			else if (rb_v_blank > 300.0 + 140 && rb_v_blank < 460.0)	rb_v_blank = 460.0;
\			else if (rb_v_blank > 460.0 + 460)							rb_v_blank = 460.0 + 460;
\		}
\		else
\			rb_v_blank = 460.0;
\
\		double h_period_est = ((1000000.0 / refresh) - rb_v_blank) / vact;
\		double vbi_lines = floor(rb_v_blank / h_period_est) + 1;
\		double rb_v_fporch = rbv == RB_CVT_V1 ? 3 : 1;
\		double rb_v_bporch = rbv == RB_CVT_V1 ? 7 : 6;
\		double rb_min_vbi = rb_v_fporch + v_sync + rb_v_bporch;
\		v_blank = vbi_lines < rb_min_vbi ? rb_min_vbi : vbi_lines;
\		if (rbv == RB_CVT_V3 && early_vsync_rqd) {
\			rb_v_bporch = floor(vbi_lines / 2.0);
\			if (v_blank - rb_v_bporch - v_sync < rb_v_fporch)
\				rb_v_bporch = v_blank - v_sync - rb_v_fporch;
\		}
\		if (rbv == RB_CVT_V1)	v_sync_bp = v_blank - rb_v_fporch;
\		else					v_sync_bp = v_sync + rb_v_bporch;
\		double total_pixels = h_blank + h_pixels_rnd;
\		h_sync = 32;
\		double refresh_multiplier = (rbv == RB_CVT_V2 && alt) ? 1000.0 / 1001.0 : 1;
\		double freq = refresh * (v_blank + vact) * total_pixels * refresh_multiplier;
\		double clock_step = rbv >= RB_CVT_V2 ? 0.001 : 0.25;
\		if (rbv == RB_CVT_V3)	pixel_freq =  ceil((freq / 1000000.0) / clock_step) * clock_step;
\		else					pixel_freq = floor((freq / 1000000.0) / clock_step) * clock_step;
\	}

\	t.hact = hact;
\	if (rbv >= RB_CVT_V2)	t.hfp = 8;
\	else					t.hfp = (h_blank / 2.0) - t.hsync;
\	t.hsync = h_sync;
\	t.hbp = h_blank - t.hfp - t.hsync;
\
\	t.vact = vact;
\	t.vfp = v_blank - v_sync_bp;
\	t.vsync = v_sync;
\	t.vbp = v_sync_bp - v_sync;
\
\	t.pos_pol_hsync = t.rbv;
\	t.pos_pol_vsync = !t.rbv;
\	t.interlaced = false;

\ ." 0:" .stack \ 304 243 123 0 0 0 460 0
		4 pick 2 >=                          if     8											\ hact vact refresh rbv alt rb_h_blank rb_v_blank early_vsync_rqd v_sync
		else 7 pick 7 pick     4 *     3 / = if     4											\ hact vact refresh rbv alt rb_h_blank rb_v_blank early_vsync_rqd v_sync
		else 7 pick 7 pick d# 16 *     9 / = if     5											\ hact vact refresh rbv alt rb_h_blank rb_v_blank early_vsync_rqd v_sync
		else 7 pick 7 pick d# 16 * d# 10 / = if     6											\ hact vact refresh rbv alt rb_h_blank rb_v_blank early_vsync_rqd v_sync
		else 7 pick 7 pick d# 15 *     9 / = if     7											\ hact vact refresh rbv alt rb_h_blank rb_v_blank early_vsync_rqd v_sync
		else 7 pick 7 pick     5 *     4 / =													\ hact vact refresh rbv alt rb_h_blank rb_v_blank early_vsync_rqd =
		                 7 pick 3 and 0= and if     7											\ hact vact refresh rbv alt rb_h_blank rb_v_blank early_vsync_rqd v_sync
		else                                    d# 10											\ hact vact refresh rbv alt rb_h_blank rb_v_blank early_vsync_rqd v_sync
		then then then then then then															\ hact vact refresh rbv alt rb_h_blank rb_v_blank early_vsync_rqd v_sync
\ ." 1:" .stack \ 304 243 123 0 0 0 460 0 10

		8 pick 6 pick 2 <> if -8 and then														\ hact vact refresh rbv alt rb_h_blank rb_v_blank early_vsync_rqd v_sync h_pixels_rnd=rb!=2?hact&-8:hact
\ ." 2:" .stack \ 304 243 123 0 0 0 460 0 10 304

		6 pick 0= if																			\ hact vact refresh rbv alt rb_h_blank rb_v_blank early_vsync_rqd v_sync h_pixels_rnd
			2swap 2drop 2swap 2drop																\ hact vact refresh rbv v_sync h_pixels_rnd

\ ." 3:" .stack \ 304 243 123 0 0 0 460 0 10 304
			0 h# f4240000 5 pick umm/round 0 h# 226000 d- 6 pick 3 + umm/round					\ hact vact refresh rbv v_sync h_pixels_rnd h_period_est:-7..18.44 = ( ( 1000000:20.44 / refresh:1..11.0 - 550:10.44 ):20.44 / (vact+3):3..17)
\ ." 4:" .stack \ 304 243 123 0 0 0 460 0 10 304 6F5BA96E 0001ED03
			0 h# 226000 2over ummm/ drop 1+														\ hact vact refresh rbv v_sync h_pixels_rnd h_period_est v_sync_bp=(floor(550:10.46 / h_period_est:4..18.46) + 1))1..17
\ ." 5:" .stack \ 304 243 123 0 0 0 460 0 10 304 6F5BA96E 0001ED03 18
			4 pick 7 + max																		\ hact vact refresh rbv v_sync h_pixels_rnd h_period_est v_sync_bp=max(v_sync_bp,v_sync+7)
\ ." 6:" .stack \ 304 243 123 0 0 0 460 0 10 304 6F5BA96E 0001ED03 18
			dup 3 +																				\ hact vact refresh rbv v_sync h_pixels_rnd h_period_est v_sync_bp v_blank=v_sync_bp+3
\ ." 7:" .stack \ 304 243 123 0 0 0 460 0 10 304 6F5BA96E 0001ED03 18 21
			0 h# 64000 2 2pick d-																\ hact vact refresh rbv v_sync h_pixels_rnd h_period_est v_sync_bp v_blank (ideal_duty_cycle:7.44 = 100:7.44 - h_period_est:18.44)
\ ." 8:" .stack \ 304 243 123 0 0 0 460 0 10 304 6F5BA96E 0001ED03 18 21 90A45692 000452FC
			dup 0< >r 2dup h# aaaaaaaa h# 42aaa du< r> or if									\ hact vact refresh rbv v_sync h_pixels_rnd h_period_est v_sync_bp v_blank ( ((ideal_duty_cycle:7.44 < 0) || (ideal_duty_cycle < 200/3:7.44)) -- )
				2drop h# 55555555 h# 8555														\ hact vact refresh rbv v_sync h_pixels_rnd h_period_est v_sync_bp v_blank ideal_duty_cycle:7.41=200/3:7.41
			else
				8 umm/round																		\ hact vact refresh rbv v_sync h_pixels_rnd h_period_est v_sync_bp v_blank ideal_duty_cycle:7.41
			then
\ ." 9:" .stack \ 304 243 123 0 0 0 460 0 10 304 6F5BA96E 0001ED03 18 21 92148AD2 00008A5F
			2dup 8 pick ud* aaaaaaaa 29aaa 2rot	d- ummm/ drop d# -16 and						\ hact vact refresh rbv v_sync h_pixels_rnd h_period_est v_sync_bp v_blank h_blank=( ( (ideal_duty_cycle*h_pixels_rnd):23:41 / (1000/3:9:41-ideal_duty_cycle:7.41) ) & -16)
\ ." 10:" .stack \ 304 243 123 0 0 0 460 0 10 304 6F5BA96E 0001ED03 18 21 64
			dup 6 roll +																		\ hact vact refresh rbv v_sync h_period_est v_sync_bp v_blank h_blank total_pixels=h_blank+h_pixels_rnd
\ ." 11:" .stack \ 304 243 123 0 0 0 460 0 10 6F5BA96E 0001ED03 18 21 64 368
			dup d# 100 / 8 * swap																\ hact vact refresh rbv v_sync h_period_est v_sync_bp v_blank h_blank h_sync=floor(total_pixels/100)*8 total_pixels
\ ." 12:" .stack \ 304 243 123 0 0 0 460 0 10 6F5BA96E 0001ED03 18 21 64 24 368

	\	1 if
			d# 10 pick 4 pick + um*	3 2roll 2drop 8 roll ud* d# 10 umm/round					\ hact vact rbv v_sync v_sync_bp v_blank h_blank h_sync pixel_freq_10Hz:32..??.0=((total_pixels * (vact + v_blank)) * refresh)/10
	\	else																					\ hact vact refresh rbv v_sync h_period_est v_sync_bp v_blank h_blank h_sync total_pixels
		\   9 roll drop																			\ hact vact rbv v_sync h_period_est v_sync_bp v_blank h_blank h_sync total_pixels
		\	d# 100000 um* h# 8000000 ud* 3 2roll h# 20000 umm/round ummm/round					\ hact vact rbv v_sync v_sync_bp v_blank h_blank h_sync pixel_freq_10Hz:32..??.0=(((total_pixels*100000):37):37.27/(h_period_est:18.44):18.27)
	\	then

		else																					\ hact vact refresh rbv alt rb_h_blank rb_v_blank early_vsync_rqd v_sync h_pixels_rnd
\ ." 13:" .stack \ hact=264 vact148 refresh=60 rbv=1 alt=0 rb_h_blank=0 rb_v_blank=460 early_vsync_rqd=0 v_sync=10 h_pixels_rnd=264

			4 roll dup 0<> 7 pick 3 = and if													\ hact vact refresh rbv alt rb_v_blank early_vsync_rqd v_sync h_pixels_rnd rb_h_blank ( (rb_h_blank<>0&&rbv==3) -- )
				-8 and																			\ hact vact refresh rbv alt rb_v_blank early_vsync_rqd v_sync h_pixels_rnd h_blank=rb_h_blank&-8
				d# 80 max d# 200 min															\ hact vact refresh rbv alt rb_v_blank early_vsync_rqd v_sync h_pixels_rnd h_blank=constrain(80,200)
			else																				\ hact vact refresh rbv alt rb_v_blank early_vsync_rqd v_sync h_pixels_rnd rb_h_blank
				drop																			\ hact vact refresh rbv alt rb_v_blank early_vsync_rqd v_sync h_pixels_rnd
				5 pick 1 = 6 pick 3 = 6 pick and or if d# 160 else d# 80 then					\ hact vact refresh rbv alt rb_v_blank early_vsync_rqd v_sync h_pixels_rnd h_blank=(rbv==1||(rbv==3&&alt))?160:80
			then																				\ hact vact refresh rbv alt rb_v_blank early_vsync_rqd v_sync h_pixels_rnd h_blank
\ ." 14:" .stack \ hact=264 vact=148 refresh=60 rbv=1 alt=0 rb_v_blank=460 early_vsync_rqd=0 v_sync=10 h_pixels_rnd=264 h_blank=160

			4 roll																				\ hact vact refresh rbv alt early_vsync_rqd v_sync h_pixels_rnd h_blank rb_v_blank
			6 pick 3 = if																		\ hact vact refresh rbv alt early_vsync_rqd v_sync h_pixels_rnd h_blank rb_v_blank ( rbv==3 -- )
				d# 300 max d# 920 min															\ hact vact refresh rbv alt early_vsync_rqd v_sync h_pixels_rnd h_blank rb_v_blank=constrain(300,920)
				dup d# 441 d# 459 between if drop d# 460 then									\ hact vact refresh rbv alt early_vsync_rqd v_sync h_pixels_rnd h_blank rb_v_blank=(440<rb_v_blank<460)?460:rb_v_blank
			else																				\ hact vact refresh rbv alt early_vsync_rqd v_sync h_pixels_rnd h_blank rb_v_blank
				drop d# 460																		\ hact vact refresh rbv alt early_vsync_rqd v_sync h_pixels_rnd h_blank rb_v_blank=460
			then																				\ hact vact refresh rbv alt early_vsync_rqd v_sync h_pixels_rnd h_blank rb_v_blank
			0 swap d# 12 <<																		\ hact vact refresh rbv alt early_vsync_rqd v_sync h_pixels_rnd h_blank rb_v_blank:9..10.44
\ ." 15:" .stack \ hact=264 vact=148 refresh=60 rbv=1 alt=0 early_vsync_rqd=0 v_sync=10 h_pixels_rnd=264 h_blank=160 rb_v_blank=0 001CC000

			0 h# f4240000 d# 10 pick umm/round 2over d- d# 11 pick umm/round					\ hact vact refresh rbv alt early_vsync_rqd v_sync h_pixels_rnd h_blank rb_v_blank:9..10.44 h_period_est:-7..18.44 = ( ( 1000000:20.44 / refresh:1..11.0 - rb_v_blank:9..10.44 ):20.44 / vact:3..17)
			ummm/ drop 1+																		\ hact vact refresh rbv alt early_vsync_rqd v_sync h_pixels_rnd h_blank vbi_lines = floor(rb_v_blank:9..10.44 / h_period_est:-7..18.44) + 1
			6 pick 1 = if																		\ hact vact refresh rbv alt early_vsync_rqd v_sync h_pixels_rnd h_blank vbi_lines
				3 7																				\ hact vact refresh rbv alt early_vsync_rqd v_sync h_pixels_rnd h_blank vbi_lines rb_v_fporch=3 rb_v_bporch=7
			else																				\ hact vact refresh rbv alt early_vsync_rqd v_sync h_pixels_rnd h_blank vbi_lines
				1 6																				\ hact vact refresh rbv alt early_vsync_rqd v_sync h_pixels_rnd h_blank vbi_lines rb_v_fporch=7 rb_v_bporch=6
			then																				\ hact vact refresh rbv alt early_vsync_rqd v_sync h_pixels_rnd h_blank vbi_lines rb_v_fporch rb_v_bporch
\ ." 16:" .stack \ hact=264 vact=148 refresh=60 rbv=1 alt=0 early_vsync_rqd=0 v_sync=10 h_pixels_rnd=264 h_blank=160 vbi_lines=2(5) rb_v_fporch=3 rb_v_bporch=7

			3dup + 7 pick + max																	\ hact vact refresh rbv alt early_vsync_rqd v_sync h_pixels_rnd h_blank vbi_lines rb_v_fporch rb_v_bporch v_blank=max(vbi_lines, rb_v_fporch+rb_v_bporch+v_sync)
			3 roll																				\ hact vact refresh rbv alt early_vsync_rqd v_sync h_pixels_rnd h_blank rb_v_fporch rb_v_bporch v_blank vbi_lines
			7 roll 0<> 9 pick 3 = and if														\ hact vact refresh rbv alt v_sync h_pixels_rnd h_blank rb_v_fporch rb_v_bporch v_blank vbi_lines ( early_vsync_rqd&&rbv==3 -- )
				rot drop																		\ hact vact refresh rbv alt v_sync h_pixels_rnd h_blank rb_v_fporch v_blank vbi_lines
				2/																				\ hact vact refresh rbv alt v_sync h_pixels_rnd h_blank rb_v_fporch v_blank rb_v_bporch=vbi_lines/2
				over 6 pick - 3 pick - min														\ hact vact refresh rbv alt v_sync h_pixels_rnd h_blank rb_v_fporch v_blank rb_v_bporch=min(rb_v_bporch,v_blank-v_sync-rb_v_fporch)
				swap																			\ hact vact refresh rbv alt v_sync h_pixels_rnd h_blank rb_v_fporch rb_v_bporch v_blank
			else																				\ hact vact refresh rbv alt v_sync h_pixels_rnd h_blank rb_v_fporch rb_v_bporch v_blank vbi_lines
				drop																			\ hact vact refresh rbv alt v_sync h_pixels_rnd h_blank rb_v_fporch rb_v_bporch v_blank
			then																				\ hact vact refresh rbv alt v_sync h_pixels_rnd h_blank rb_v_fporch rb_v_bporch v_blank
\ ." 17:" .stack \ hact=264 vact=148 refresh=60 rbv=1 alt=0 v_sync=10 h_pixels_rnd=264 h_blank=160 rb_v_fporch=3 rb_v_bporch=7 v_blank=20

			7 pick 1 = if																		\ hact vact refresh rbv alt v_sync h_pixels_rnd h_blank rb_v_fporch rb_v_bporch v_blank
				nip																				\ hact vact refresh rbv alt v_sync h_pixels_rnd h_blank rb_v_fporch v_blank
				dup rot -																		\ hact vact refresh rbv alt v_sync h_pixels_rnd h_blank v_blank v_sync_bp=v_blank-rb_v_fporch
\ ." 18:" .stack \ hact=264 vact=148 refresh=60 rbv=1 alt=0 v_sync=10 h_pixels_rnd=264 h_blank=160 v_blank=20 v_sync_bp=17
			else																				\ hact vact refresh rbv alt v_sync h_pixels_rnd h_blank rb_v_fporch rb_v_bporch v_blank
				rot drop																		\ hact vact refresh rbv alt v_sync h_pixels_rnd h_blank rb_v_bporch v_blank
				swap 4 pick +																	\ hact vact refresh rbv alt v_sync h_pixels_rnd h_blank v_blank v_sync_bp=rb_v_bporch+v_sync
\ ." 19:" .stack
			then																				\ hact vact refresh rbv alt v_sync h_pixels_rnd h_blank v_blank v_sync_bp

			swap rot d# 32																		\ hact vact refresh rbv alt v_sync h_pixels_rnd v_sync_bp v_blank h_blank h_sync=32
			4 roll 2 pick +	8 roll * 8 pick 4 pick + um*										\ hact vact rbv alt v_sync v_sync_bp v_blank h_blank h_sync freq=(h_pixels_rnd+h_blank)*refresh*(vact+v_blank)
			7 roll 8 pick 2 = and if															\ hact vact rbv v_sync v_sync_bp v_blank h_blank h_sync freq:32..??.0 ( alt&&rbv==2 -- )
				d# 100 ud* d# 1001 umm/round													\ hact vact rbv v_sync v_sync_bp v_blank h_blank h_sync pixel_freq_10Hz=freq:32..??.0*1000/1001/10
\ ." 20:" .stack
			else
				d# 10 umm/round																	\ hact vact rbv v_sync v_sync_bp v_blank h_blank h_sync pixel_freq_10Hz=freq:32..??.0*1000/1001/10
\ ." 21:" .stack \ hact=264 vact=148 rbv=1 0 17 20 160 32 00068580 0
			then																				\ hact vact rbv v_sync v_sync_bp v_blank h_blank h_sync pixel_freq_10Hz:32..??.0

		then																					\ hact vact rbv v_sync v_sync_bp v_blank h_blank h_sync pixel_freq_10Hz:32..??.0
		if																						\ hact vact rbv v_sync v_sync_bp v_blank h_blank h_sync pixel_freq_10Hz
\ ." 22:" .stack
			2drop 2drop 2drop 3drop false exit													\ false
\ ." 23:" .stack
		then
\ ." 24:" .stack

		>r																						\ hact vact rbv v_sync v_sync_bp v_blank h_blank h_sync \ pixel_freq_10Hz

		7 roll dup >r																			\ vact rbv v_sync v_sync_bp v_blank h_blank h_sync hact \ pixel_freq_10Hz width=hact
		dup >r																					\ vact rbv v_sync v_sync_bp v_blank h_blank h_sync hact \ pixel_freq_10Hz width hactive=hact
		6 pick 2 >= if 8 else 2 pick u2/ 2 pick - then											\ vact rbv v_sync v_sync_bp v_blank h_blank h_sync hact hfp=((rbv>= 2) ? 8 : (h_blank / 2.0) - t.hsync) \ pixel_freq_10Hz width hactive
		over + dup >r																			\ vact rbv v_sync v_sync_bp v_blank h_blank h_sync hact hsb \ pixel_freq_10Hz width hactive hsb=hfp+hact
		rot + >r																				\ vact rbv v_sync v_sync_bp v_blank h_blank hact \ pixel_freq_10Hz width hactive hsb hse=hsb+hsync
		+ >r																					\ vact rbv v_sync v_sync_bp v_blank \ pixel_freq_10Hz width hactive hsb hse htot=h_blank+hact
\ ." 25:" .stack

		4 roll dup >r																			\ rbv v_sync v_sync_bp v_blank vact \ pixel_freq_10Hz width hactive hsb hse htot height=vact
\ ." 26:" .stack
		dup >r																					\ rbv v_sync v_sync_bp v_blank vact \ pixel_freq_10Hz width hactive hsb hse htot height vactive
\ ." 27:" .stack
		2dup + 3 roll -	dup >r																	\ rbv v_sync v_blank vact vsb \ pixel_freq_10Hz width hactive hsb hse htot height vactive vsb=v_blank+vact-v_sync_bp
\ ." 28:" .stack
		3 roll +																				\ rbv v_blank vact vse=vsb+v_sync \ pixel_freq_10Hz width hactive hsb hse htot height vactive vsb
\ ." 29:" .stack
		>r																						\ rbv v_blank vact \ pixel_freq_10Hz width hactive hsb hse htot height vactive vsb vse=vsb+v_sync
		+																						\ rbv vtot=v_blank+vact \ pixel_freq_10Hz width hactive hsb hse htot height vactive vsb vse
\ ." 30:" .stack
		>r																						\ rbv \ pixel_freq_10Hz width hactive hsb hse htot height vactive vsb vse vtot=v_blank+vact

		dup 0<> dup >r																			\ rbv hp \ pixel_freq_10Hz width hactive hsb hse htot height vactive vsb vse vtot hpolarity=(rbv!=0)
		not >r																					\ rbv \ pixel_freq_10Hz width hactive hsb hse htot height vactive vsb vse vtot hpolarity vpolarity=!hp
		false >r																				\ \ pixel_freq_10Hz width hactive hsb hse htot height vactive vsb vse vtot hpolarity vpolarity interlaced
		false >r																				\ \ pixel_freq_10Hz width hactive hsb hse htot height vactive vsb vse vtot hpolarity vpolarity interlaced csyncdisabled

		case
		0 of " CVT"(00)"     endof
		1 of " CVT-RB"(00)"  endof
		2 of " CVT-RB2"(00)" endof
		3 of " CVT-RB3"(00)" endof
		endcase																					\ noteaddr notelen \ pixel_freq_10Hz width hactive hsb hse htot height vactive vsb vse vtot hpolarity vpolarity interlaced csyncdisabled

\ ." 36:" .stack
		r> r> r> r> r> r> r> r> r> r> r> r> r> r> r>											\ noteaddr notelen csyncdisabled interlaced vpolarity hpolarity vtot vse vsb vactive height htot hse hsb hactive width pixel_freq_10Hz
		store-and-return-timing																	\ temp-display-timing true
\ ." 37:" .stack
\		" ] edid-cvt-mode success" .dbg cr
		;

	: edid-gtf-mode ( hact vact refresh -- false | timing true )
\		" [ edid-gtf-mode " .dbg 2 pick .d ." x " over .d ." @ " dup .d ." Hz" cr

		\ only works with these ranges:
		\    hact: 248..2288 and multiple of 8
		\    vact: 139..2288
		\ refresh:  60..123

		\ (  1 ) h_period_est = ((1.0 / refresh) - 550.0 / 1000000.0) / (vact + 1.0) * 1000000.0;
		\ (  2 ) v_sync_bp = round(550.0 / h_period_est); vtotal = vact + v_sync_bp + 1.0;
		\ (  3 ) h_period = h_period_est / (refresh / (1.0 / h_period_est / vtotal * 1000000.0));		\ h_period = 1000000.0 / (vtotal * refresh)
		\ (  4 ) ideal_duty_cycle = 30 - (h_period * 3 / 10.0);
		\ (  5 ) if ideal_duty_cycle < 0 then fail
		\ (  6 ) h_blank_pixels = round16(hact * ideal_duty_cycle / (100.0 - ideal_duty_cycle)); // 16 because CELL_GRAN is 8
		\ (  7 ) total_pixels = hact + h_blank_pixels;
		\ (  8 ) pixel_freq_MHz = (* total_pixels / h_period *) total_pixels * vtotal * refresh;
		\ (  9 ) hsync = round8(total_pixels * 8%);
		\ ( 10 ) hfp = (h_blank_pixels / 2.0) - hsync;
		\ ( 11 ) if hfp < 0 then fail
		\ ( 12 ) hbp = hfp + hsync;

(  1 )	0 h# f4240000 2 pick umm/round 0 h# 226000 d- d# 64 ud* 3 pick 1+ umm/round	\ hact vact refresh h_period_est:7.50 = ( (( 1000000:20.44 / refresh:6-7.0 - 550:10.44 ):14.44 << 6):14.50 / (vact+1):8)
\ ." 1:" .stack
(  2 )	0 h# 8980000 2swap ummm/round drop											\ hact vact refresh v_sync_bp=round(550:10.50 / h_period_est:7.50):8
		2 pick + 1+																	\ hact vact refresh vtotal=v_sync_bp+vact+1
\ ." 2:" .stack
(  3 )	0 h# f4240000 2over * umm/round												\ hact vact refresh vtotal h_period:7.44 = ( 1000000:20.44 / (refresh:7 * vtotal:12):19 ):7.44
\ ." 3:" .stack
(  4 )	0 0f000000 2swap h# 1800 ud* d# 10 umm/round d-								\ hact vact refresh vtotal ideal_duty_cycle:6.55 = (30:5.55 - ((h_period:7.44*3:2.11):9.55 / 10):6.55)
\ ." 4:" .stack
(  5 )	dup 0< if
			2drop 2drop 2drop false													\ false
\			" ] edid-gtf-mode fail ideal_duty_cycle" .dbg cr
			exit
		then																		\ hact vact refresh vtotal ideal_duty_cycle:5.55
\ ." 5:" .stack
(  6 )	2dup d# 1024 umm/round 7 pick ud* 2swap 0 h# 32000000 2swap d-				\ hact vact refresh vtotal (ideal_duty_cycle:5.45*hact:12):17.45 (100:7.55 - ideal_duty_cycle:5.55):7.55
		nip um/round d# 22 >> 8 + d# -16 and										\ hact vact refresh vtotal h_blank_pixels:10.0 = ( (((ideal_duty_cycle:5.45*hact:12):17.45 / (100:7.55 - ideal_duty_cycle:5.55):7.23):10.22):10.0 + 8) & ~f
\ ." 6:" .stack
(  7 )	dup 5 pick +																\ hact vact refresh vtotal h_blank_pixels:10.0 total_pixels=h_blank_pixels+hact
\ ." 7:" .stack
(  9 )	h# a3d70a3d h# a3d70 2 pick ud* nip d# 23 >> 4 + -8 and						\ hact vact refresh vtotal h_blank_pixels:10.0 total_pixels hsync=round8((((8%:0.55 * total_pixels:12.0):9.55):9.23):9.0)
\ ." 9:" .stack
( 10 )  rot u2/ over -																\ hact vact refresh vtotal total_pixels hsync hfp = h_blank_pixels:10.0 / 2 - hsync
\ ." 10:" .stack
( 11 )	dup 0< if																	\ hact vact refresh vtotal total_pixels hsync hfp
			2drop 2drop 3drop false													\ false
\			" ] edid-gtf-mode fail hfp" .dbg cr
			exit
		then
\ ." 11:" .stack
( 12 )	2dup +																		\ hact vact refresh vtotal total_pixels hsync hfp hbp=hsync+hfp
\ ." 12:" .stack

		5 roll 5 pick 5 pick * * d# 10 u/round >r									\ hact vact vtotal total_pixels hsync hfp hbp \ pixel_freq_10Hz=refresh*vtotal*total_pixels

		6 roll dup >r																\ vact vtotal total_pixels hsync hfp hbp hact \ pixel_freq_10Hz width=hact
		dup >r																		\ vact vtotal total_pixels hsync hfp hbp hact \ pixel_freq_10Hz width hactive=hact
		rot + dup >r																\ vact vtotal total_pixels hsync hbp hsb \ pixel_freq_10Hz width hactive hsb=hact+hfp
		rot + >r																	\ vact vtotal total_pixels hbp \ pixel_freq_10Hz width hactive hsb hse=hsb+hsync
		drop >r																		\ vact vtotal \ pixel_freq_10Hz width hactive hsb hse htot

		swap dup >r																	\ vtotal vact \ pixel_freq_10Hz width hactive hsb hse htot height=vact
		dup >r																		\ vtotal vact \ pixel_freq_10Hz width hactive hsb hse htot height vactive
		1+ dup >r																	\ vtotal vsb \ pixel_freq_10Hz width hactive hsb hse htot height vactive vsb=vact+1
		3 + >r																		\ vtotal \ pixel_freq_10Hz width hactive hsb hse htot height vactive vsb vse=vsb+3
		>r																			\ \ pixel_freq_10Hz width hactive hsb hse htot height vactive vsb vse vtot

		N			>r																\ \ pixel_freq_10Hz width hactive hsb hse htot height vactive vsb vse vtot hpolarity
		P			>r																\ \ pixel_freq_10Hz width hactive hsb hse htot height vactive vsb vse vtot hpolarity vpolarity
		false		>r																\ \ pixel_freq_10Hz width hactive hsb hse htot height vactive vsb vse vtot hpolarity vpolarity interlaced
		false		>r																\ \ pixel_freq_10Hz width hactive hsb hse htot height vactive vsb vse vtot hpolarity vpolarity interlaced csyncdisabled
		" GTF"(00)"																	\ noteaddr notelen \ pixel_freq_10Hz width hactive hsb hse htot height vactive vsb vse vtot hpolarity vpolarity interlaced csyncdisabled

		r> r> r> r> r> r> r> r> r> r> r> r> r> r> r>								\ noteaddr notelen csyncdisabled interlaced vpolarity hpolarity vtot vse vsb vactive height htot hse hsb hactive width pixel_freq_10Hz
		store-and-return-timing														\ temp-display-timing true
\		" ] edid-gtf-mode success" .dbg cr
		;

	: calc-standard-timing ( gtfonly byte1 byte2 display-info -- done? )
\ ." 0:" .stack
\		" [ calc-standard-timing gtfonly:" .dbg 3 pick .d ."  bytes: " 2 pick 2 u.r space over 2 u.r cr
		-rot															\ gtfonly display_info byte1 byte2
		over 1 <= if
\ ." 1:" .stack
			2drop 2drop false
\			" ] calc-standard-timing invalid done: 0" .dbg cr
			exit
		then															\ gtfonly display_info byte1 byte2

\ ." 2:" .stack FF866740 FF866740 FF866740 FFFFFFFF FF866740 FF8D8FA3 gtfonly=false display_info=FF8D8FA3 byte1=31 byte2=59
		swap d# 31 + 8 *												\ gtfonly display_info byte2 hact
\ ." 3:" .stack
		over 6 >> 3 and case											\ gtfonly display_info byte2 hact aspect
			0 of														\ gtfonly display_info byte2 hact
\ ." 4:" .stack
				2 pick p-edid-revision 3 >=								\ gtfonly display_info byte2 hact revision>=3
				4 pick or												\ gtfonly display_info byte2 hact revision>=3||gtfonly
				if
					d# 16 d# 10
				else
					1 1
				then
			endof
			1 of 4 3 endof
			2 of 5 4 endof
			3 of d# 16 9 endof
		endcase															\ gtfonly display_info byte2 hact hratio vratio
\ ." 5:" .stack
		2 pick * swap /													\ gtfonly display_info byte2 hact vact=vratio*hact/hratio
\ ." 6:" .stack
		rot 3f and d# 60 +												\ gtfonly display_info hact vact refresh
\ ." 7:" .stack \ FF866740 FF866740 FF866740 FFFFFFFF FF866740 FF8D8FA3 gtf-only=false display_info=FF8D8FA3  hact=640 vact=480 refresh=85

		4 pick 0= 4 pick p-edid-revision 4 >= and if					\ gtfonly display_info hact vact refresh ( !gtfonly&&revision>=4 -- )
\ ." 8:" .stack
			3 pick p-edid-supports-cvt?									\ gtfonly display_info hact vact refresh do_cvt
			true														\ gtfonly display_info hact vact refresh do_cvt do_gtf
		else 4 pick 4 pick p-edid-revision 2 >= or if					\ gtfonly display_info hact vact refresh ( gtfonly||revision>=2 -- )
\ ." 9:" .stack
			false true													\ gtfonly display_info hact vact refresh do_cvt do_gtf
		else															\ gtfonly display_info hact vact refresh
\ ." 10:" .stack
			false true \ assume GTF since we don't do DMT lookup		\ gtfonly display_info hact vact refresh do_cvt do_gtf
		then then														\ gtfonly display_info hact vact refresh do_cvt do_gtf

\ ." 11:" .stack
		>r if															\ gtfonly display_info hact vact refresh \ R: do_gtf
\ ." 12:" .stack
			3dup 0 false 0 d# 460 false edid-cvt-mode if				\ gtfonly display_info hact vact refresh display_timing \ R: do_gtf
\ ." 13:" .stack
				4 pick timing-proc ( display-timing display-info -- done? )
\ ." 14:" .stack
				if														\ gtfonly display_info hact vact refresh \ R: do_gtf
\ ." 15:" .stack
\					" ] calc-standard-timing cvt done: -1" .dbg cr
					r> 2drop 2drop 2drop true exit						\ done? = true
				then
			then														\ gtfonly display_info hact vact refresh \ R: do_gtf
		then															\ gtfonly display_info hact vact refresh \ R: do_gtf

\ ." 16:" .stack
		r> if															\ gtfonly display_info hact vact refresh
			edid-gtf-mode if											\ gtfonly display_info display_timing
\ ." 17:" .stack
				over													\ gtfonly display_info display_timing display_info
				timing-proc ( display-timing display-info -- done? )	\ gtfonly display_info done?
				nip nip													\ done?
			else														\ gtfonly display_info
				2drop false												\ done? = false
			then
		else															\ gtfonly display_info hact vact refresh
\ ." 18:" .stack
			3drop 2drop false											\ done? = false
		then															\ done?
\		" ] calc-standard-timing done: " .dbg dup .d cr
		;

	: calc-standard-timings ( std_timings size display-info -- done? )
\		" [ calc-standard-timings" .dbg cr
		-rot															\ display-info std_timings size
		bounds do														\ display_info
			false i c@++ c@ 3 pick calc-standard-timing					\ display_info ( false byte1 byte2 display_info -- done? )
			if															\ display_info
				unloop drop true										\ true
\				" ] calc-standard-timings done" .dbg cr
				exit
			then														\ display_info
		2 +loop															\ display_info
		drop false														\ false
\		" ] calc-standard-timings" .dbg cr
		;

	: detailed-cvt-descriptor ( byte1 byte2 byte3 display-info -- done? )
		" [ detailed-cvt-descriptor bytes: " .dbg 3 pick 2 u.r space 2 pick 2 u.r space over 2 u.r cr
		3 roll dup 0= if												\ byte2 byte3 display_info vact
			2drop 2drop false											\ false
			" ] detailed-cvt-descriptor done: false" .dbg cr
			exit
		then															\ byte2 byte3 display_info vact
		3 pick 4 >> bwjoin 1+ 2*										\ byte2 byte3 display_info vact
		3 roll 2 >> 3 and case											\ byte3 display_info vact (byte2>>2)&3
			0 of     3     4 endof
			1 of     9 d# 16 endof
			2 of d# 10 d# 16 endof
			3 of     9 d# 15 endof
		endcase															\ byte3 display_info vact vratio hratio
		2 pick * swap / -8 and swap										\ byte3 display_info hact=hratio*vact/vratio vact
\ ."  0:" .stack

		3 pick h# 10 and if												\ byte3 display_info hact vact
\ ."  1:" .stack
			2dup d# 50 0 false 0 d# 460 false edid-cvt-mode if			\ byte3 display_info hact vact timing
\ ."  2:" .stack
				3 pick													\ byte3 display_info hact vact timing display_info
\ ."  3:" .stack
				timing-proc ( display-timing display-info -- done? )	\ byte3 display_info hact vact done?
\ ."  4:" .stack
				if														\ byte3 display_info hact vact
\ ."  5:" .stack
					2drop 2drop true exit								\ true
\ ."  6:" .stack
				then													\ byte3 display_info hact vact
			then														\ byte3 display_info hact vact
		then															\ byte3 display_info hact vact

		3 pick h# 8 and if												\ byte3 display_info hact vact
\ ."  7:" .stack
			2dup d# 60 0 false 0 d# 460 false edid-cvt-mode if			\ byte3 display_info hact vact timing
\ ."  8:" .stack
				3 pick													\ byte3 display_info hact vact timing display_info
\ ."  9:" .stack
				timing-proc ( display-timing display-info -- done? )	\ byte3 display_info hact vact done?
\ ." 10:" .stack
				if														\ byte3 display_info hact vact
\ ." 11:" .stack
					2drop 2drop true exit								\ true
\ ." 12:" .stack
				then													\ byte3 display_info hact vact
			then														\ byte3 display_info hact vact
		then															\ byte3 display_info hact vact

		3 pick h# 4 and if												\ byte3 display_info hact vact
\ ." 13:" .stack
			2dup d# 75 0 false 0 d# 460 false edid-cvt-mode if			\ byte3 display_info hact vact timing
\ ." 14:" .stack
				3 pick													\ byte3 display_info hact vact timing display_info
\ ." 15:" .stack
				timing-proc ( display-timing display-info -- done? )	\ byte3 display_info hact vact done?
\ ." 16:" .stack
				if														\ byte3 display_info hact vact
\ ." 17:" .stack
					2drop 2drop true exit								\ true
\ ." 18:" .stack
				then													\ byte3 display_info hact vact
			then														\ byte3 display_info hact vact
		then															\ byte3 display_info hact vact

		3 pick h# 2 and if												\ byte3 display_info hact vact
\ ." 19:" .stack
			2dup d# 85 0 false 0 d# 460 false edid-cvt-mode if			\ byte3 display_info hact vact timing
\ ." 20:" .stack
				3 pick													\ byte3 display_info hact vact timing display_info
\ ." 21:" .stack
				timing-proc ( display-timing display-info -- done? )	\ byte3 display_info hact vact done?
\ ." 22:" .stack
				if														\ byte3 display_info hact vact
\ ." 23:" .stack
					2drop 2drop true exit								\ true
\ ." 24:" .stack
				then													\ byte3 display_info hact vact
			then														\ byte3 display_info hact vact
		then															\ byte3 display_info hact vact

		3 pick h# 1 and if												\ byte3 display_info hact vact
\ ." 25:" .stack
			2dup d# 60 1 false 0 d# 460 false edid-cvt-mode if			\ byte3 display_info hact vact timing
\ ." 26:" .stack
				3 pick													\ byte3 display_info hact vact timing display_info
\ ." 27:" .stack
				timing-proc ( display-timing display-info -- done? )	\ byte3 display_info hact vact done?
\ ." 28:" .stack
				if														\ byte3 display_info hact vact
\ ." 29:" .stack
					2drop 2drop true exit								\ true
\ ." 30:" .stack
				then													\ byte3 display_info hact vact
			then														\ byte3 display_info hact vact
		then															\ byte3 display_info hact vact
		2drop 2drop false												\ false
\ ." 31:" .stack
		" ] detailed-cvt-descriptor" .dbg cr
		;

	: detailed-cvt-descriptors ( cvts size display-info -- done? )
		" [ detailed-cvt-descriptors" .dbg cr
		-rot															\ display-info cvts size
		bounds do														\ display_info
			i c@++ c@++ c@ 3 pick										\ display_info byte1 byte2 byte3 display_info
			detailed-cvt-descriptor if									\ display_info
				unloop drop true										\ true
\				" ] detailed-cvt-descriptors done" .dbg cr
				exit
			then														\ display_info
		3 +loop
		drop false														\ false
		" ] detailed-cvt-descriptors" .dbg cr
		;

	: .timing ( display-timing -- )
		base @ decimal swap										\ base display_timing
		dup    >T.pixel-clock l@								\ base display_timing display_timing.pixel_clock^
		over   >T.interlaced c@									\ base display_timing display_timing.pixel_clock^ interlaced?
		if d# 20000000 else d# 10000000 then					\ base display_timing display_timing.pixel_clock^ 1000|2000
		um*														\ base display_timing display_timing.pixel_clock^*10*100 hi

		2 pick >T.hactive w@ 0 <# #s #> type ." x"				\ base display_timing display_timing.pixel_clock^*10*100 hi
		2 pick >T.vactive w@ 0 <# #s #> type					\ base display_timing display_timing.pixel_clock^*10*100 hi
		2 pick >T.interlaced c@ if ." i" then					\ base display_timing display_timing.pixel_clock^*10*100 hi
		space

		2 pick >T.htotal w@										\ base display_timing display_timing.pixel_clock^*10*100 hi htotal
		3 pick >T.vtotal w@										\ base display_timing display_timing.pixel_clock^*10*100 hi htotal vtotal
		*														\ base display_timing display_timing.pixel_clock^*10*100 hi htotal*vtotal
		um/round
		0														\ base display_timing refresh_rate_hundredths_double
		\ digits are pictured from right to left
		<# # # # # # # [char] . hold #s #> type					\ base display_timing
		."  Hz "												\ base display_timing

		dup >T.pixel-clock l@ d# 10 um*							\ base display_timing MHz
		<# # # # # # # [char] . hold #s #> type
		."  MHz "												\ base display_timing

		dup >T.hactive		w@									\ base display_timing active
		over >T.hsyncbegin  w@ tuck swap - .d					\ base display_timing syncbegin
		over >T.hsyncend    w@ tuck swap - .d					\ base display_timing syncend
		over >T.htotal      w@      swap - .d					\ base display_timing
		dup >T.hpolarity	c@ if ." P " else ." N " then		\ base display_timing

		dup >T.vactive		w@									\ base display_timing active
		over >T.vsyncbegin  w@ tuck swap - .d					\ base display_timing syncbegin
		over >T.vsyncend    w@ tuck swap - .d					\ base display_timing syncend
		over >T.vtotal      w@      swap - .d					\ base display_timing
		dup >T.vpolarity	c@ if ." P " else ." N " then		\ base display_timing
		cr
		drop base !
		;

	: test-gtf-timings ( -- )
		cr																\
		100 2 do														\
			i d# 31 + 8 *												\ hact
			5 0 do														\ hact
				i case													\ hact aspect
					0 of d# 16     9 endof								\ hact hratio vratio
					1 of d# 16 d# 10 endof								\ hact hratio vratio
					2 of     4     3 endof								\ hact hratio vratio
					3 of     5     4 endof								\ hact hratio vratio
					4 of     1     1 endof								\ hact hratio vratio
				endcase													\ hact hratio vratio
				2 pick * swap /											\ hact vact=vratio*hact/hratio
				40 0 do													\ hact vact
					i d# 60 +											\ hact vact refresh
					3dup edid-gtf-mode if								\ hact vact refresh display_timing
						.timing											\ hact vact refresh
					then												\ hact vact refresh
					drop												\ hact vact
				loop													\ hact vact
				drop													\ hact
			loop														\ hact
			drop														\
		loop															\
		;

	: test-one-cvt-timings ( rbv -- )
		cr																\ rbv
		100 2 do														\ rbv
			i d# 31 + 8 *												\ rbv hact
			5 0 do														\ rbv hact
				i case													\ rbv hact aspect
					0 of d# 16     9 endof								\ rbv hact hratio vratio
					1 of d# 16 d# 10 endof								\ rbv hact hratio vratio
					2 of     4     3 endof								\ rbv hact hratio vratio
					3 of     5     4 endof								\ rbv hact hratio vratio
					4 of     1     1 endof								\ rbv hact hratio vratio
				endcase													\ rbv hact hratio vratio
				2 pick * swap /											\ rbv hact vact=vratio*hact/hratio
				40 0 do													\ rbv hact vact
					i d# 60 +											\ rbv hact vact refresh
					3dup 6 pick false 0 d# 460 false edid-cvt-mode if	\ rbv hact vact refresh ( hact vact refresh rbv alt=false rb_h_blank=0 rb_v_blank=460 early_vsync_rqd=false -- false | timing true )
						.timing											\ rbv hact vact refresh
					then												\ rbv hact vact refresh
					drop												\ rbv hact vact
				loop													\ rbv hact vact
				drop													\ rbv hact
			loop														\ rbv hact
			drop														\ rbv
		loop															\ rbv
		drop															\
		;

	: test-cvt-timings ( -- )
		4 0 do
			cr
			." rbv: " i . cr
			i test-one-cvt-timings
		loop
		;

	: parse-detailed-timings ( descriptor -- false | timing true )
\		" [ parse-detailed-timings" .dbg cr
		dup >dtd.pixel-clock 2c@-le d# 1000 * >r												\ descriptor \ pixel_freq_10Hz

		dup >dtd.hact c@ over >dtd.hact,hbl c@ 4 >> bwjoin										\ descriptor hact \ pixel_freq_10Hz
		dup	>r																					\ descriptor hact \ pixel_freq_10Hz width
		dup	>r																					\ descriptor hact \ pixel_freq_10Hz width hactive
		dup																						\ descriptor hact hact
		2 pick >dtd.hfp c@ 3 pick >dtd.hfp,hsp,vfp,vsp c@ 6 >> bwjoin							\ descriptor hact hact hfp
		+ dup >r																				\ descriptor hact hsb \ pixel_freq_10Hz width hactive hsb
		2 pick >dtd.hsp c@ 3 pick >dtd.hfp,hsp,vfp,vsp c@ 4 >> 3 and bwjoin						\ descriptor hact hsb hsp
		+ >r																					\ descriptor hact \ pixel_freq_10Hz width hactive hsb hse
		over >dtd.hbl c@ 2 pick >dtd.hact,hbl c@ h# f and bwjoin 2 pick >dtd.hborder c@ 2* -	\ descriptor hact hbl
		+ >r																					\ descriptor \ pixel_freq_10Hz width hactive hsb hse htot

		dup >dtd.vact c@ over >dtd.vact,vbl c@ 4 >> bwjoin										\ descriptor vact
		over >dtd.features c@ 7 >> <<															\ descriptor vact *= interalaced?2:1
		dup >r																					\ descriptor vact \ pixel_freq_10Hz width hactive hsb hse htot height
		dup >r																					\ descriptor vact \ pixel_freq_10Hz width hactive hsb hse htot height vactive
		dup																						\ descriptor vact vact
		2 pick >dtd.vfp,vsp c@ 4 >> 3 pick >dtd.hfp,hsp,vfp,vsp c@ h# c and 2 << or				\ descriptor vact vact vfp
		+ dup >r																				\ descriptor vact vsb \ pixel_freq_10Hz width hactive hsb hse htot height vactive vsb
		2 pick >dtd.vfp,vsp c@ h# f and 3 pick >dtd.hfp,hsp,vfp,vsp c@ 3 and 4 << or			\ descriptor vact vsb vsp
		+ >r																					\ descriptor vact \ pixel_freq_10Hz width hactive hsb hse htot height vactive vsb vse
		over >dtd.vbl c@ 2 pick >dtd.vact,vbl c@ h# f and bwjoin 2 pick >dtd.vborder c@ 2* -	\ descriptor vact vbl
		+ >r																					\ descriptor \ pixel_freq_10Hz width hactive hsb hse htot height vactive vsb vse vtot

		>dtd.features c@																		\ features
		dup 3 >> 3 and case																		\ features synctype
			2 of
				dup 2 and 0<> false false														\ features hpolarity vpolarity csyncdisabled
			endof
			3 of
				dup 2 and 0<> over 1 and 0<> true												\ features hpolarity vpolarity csyncdisabled
			endof
			dup of
				false false false																\ features hpolarity vpolarity csyncdisabled
			endof
		endcase
		rot >r																					\ features vpolarity csyncdisabled \ pixel_freq_10Hz width hactive hsb hse htot height vactive vsb vse vtot hpolarity
		swap >r																					\ features csyncdisabled \ pixel_freq_10Hz width hactive hsb hse htot height vactive vsb vse vtot hpolarity vpolarity
		swap h# 80 and 0<> >r																	\ csyncdisabled \ pixel_freq_10Hz width hactive hsb hse htot height vactive vsb vse vtot hpolarity vpolarity interlaced=features&0x80
		>r																						\ \ pixel_freq_10Hz width hactive hsb hse htot height vactive vsb vse vtot hpolarity vpolarity interlaced csyncdisabled
		" DTD"(00)"

		r> r> r> r> r> r> r> r> r> r> r> r> r> r> r>											\ noteaddr notelen csyncdisabled interlaced vpolarity hpolarity vtot vse vsb vactive height htot hse hsb hactive width pixel_freq_10Hz
		store-and-return-timing
\		.stack
\		" ] parse-detailed-timings" .dbg cr
		;

	: parse-established-timings ( allmodes? et_bits table display_info -- done? )
\		" [ parse-established-timings" .dbg cr
\ ." 1:" .stack \ allmodes?=true et_bits=FF8D8FA3 table=FF85DDC0 display_info=FF866740
		3 roll if														\ et_bits table display_info
\ ." 2:" .stack \ et_bits=FF8D8FA3 table=FF85DDC0 display_info=FF866740
			100 0 do													\ et_bits table display_info
\ ." 3:" .stack \  et_bits=FF8D8FA3 table=FF85DDC0 display_info=FF866740
				over i la+ l@ ?dup if									\ et_bits table display_info timing
\ ." 4:" .stack \  et_bits=FF8D8FA3 table=FF85DDC0 display_info=FF866740 timing=FF859D50
					3 pick i 3 >> ca+ c@ h# 80 i 7 and >> and			\ et_bits table display_info timing byte&(0x80>>(i&7))
					if													\ et_bits table display_info timing
\ ." 5:" .stack
						over timing-proc								\ et_bits table display_info ( display-timing display-info -- done? )
\ ." 6:" .stack
						if												\ et_bits table display_info
\ ." 7:" .stack
							unloop 3drop true exit						\ true
						then											\ et_bits table display_info
					else												\ et_bits table display_info timing
						drop											\ et_bits table display_info
					then												\ et_bits table display_info
				else													\ et_bits table display_info
					leave												\ et_bits table display_info
				then													\ et_bits table display_info
			loop														\ et_bits table display_info
		then															\ et_bits table display_info
\ ." 8:" .stack
		3drop false														\ false
\ ." 9:" .stack
\		" ] parse-established-timings" .dbg cr
		;

	: parse-detailed-timing-descriptor ( allmodes? descriptor display_info -- done? )
		" [ parse-detailed-timing-descriptor " .dbg 2 pick .d over 8 u.r dup space 8 u.r cr
		over 2c@-le if													\ allmodes? descriptor display_info
			rot drop													\ descriptor display_info
			swap parse-detailed-timings	if								\ display_info ( descriptor -- false | timing true )
				swap													\ timing display_info
				timing-proc ( display-timing display-info -- done? )	\ done?
				" ] parse-detailed-timing-descriptor: DTD" .dbg cr
			else														\ display_info
				drop false												\ done?
				" ] parse-detailed-timing-descriptor: Not DTD" .dbg cr
			then														\ done?
			exit														\ done?
		then															\ allmodes? descriptor display_info
		swap															\ allmodes? display_info descriptor
		dup 3 + c@ case
			h# f7 of													\ allmodes? display_info descriptor
				6 + established-timings-iii rot							\ allmodes? et_bits table display_info
				parse-established-timings ( allmodes? et_bits table display_info -- done? )
				" ] parse-detailed-timing-descriptor: Established timings III" .dbg cr
				exit
			endof
			h# f8 of													\ allmodes? display_info descriptor
				rot drop 6 + d# 12 rot
				detailed-cvt-descriptors ( cvts size display-info -- done? )
				" ] parse-detailed-timing-descriptor: CVT 3 Byte Timing Codes" .dbg cr
				exit
			endof
			h# fa of													\ allmodes? display_info descriptor
				rot drop 5 + d# 12 rot									\ std-timings 12 display_info
				calc-standard-timings ( std_timings size display-info -- done? )
				" ] parse-detailed-timing-descriptor: Standard Timing Identifications" .dbg cr
				exit
			endof
		endcase															\ allmodes? display_info descriptor
		3drop false
		" ] parse-detailed-timing-descriptor" .dbg cr
		;

	: .hexstring ( start len -- )
		bounds ?do i c@ 2 u.r loop
		;

	h# 1000 constant kOUI_HDMI      
	h# 2000 constant kOUI_HDMIForum 
	h# 3000 constant kOUI_HDR10     
	h# 4000 constant kOUI_AMD       
	h# 5000 constant kOUI_NVIDIA    
	h# 6000 constant kOUI_ASUS      
	h# 7000 constant kOUI_Apple     
	h# 8000 constant kOUI_MSTAR     
	h# 9000 constant kOUI_Dolby     
	h# A000 constant kOUI_InFocus
	h# B000 constant kOUI_Microsoft
	h# C000 constant kOUI_THX
	h# D000 constant kOUI_UHDA
	h# E000 constant kOUI_VESA

	: oui-num ( oui -- ouinum )
		case
			h# 000c03 of kOUI_HDMI       endof  \ HDMI
			h# c45dd8 of kOUI_HDMIForum  endof  \ HDMI Forum
			h# 90848b of kOUI_HDR10      endof  \ HDR10+
			h# 00001a of kOUI_AMD        endof  \ AMD
			h# 00044b of kOUI_NVIDIA     endof  \ NVIDIA
			h# 000c6e of kOUI_ASUS       endof  \ ASUS
			h# 0010fa of kOUI_Apple      endof  \ Apple
			h# 0014b9 of kOUI_MSTAR      endof  \ MSTAR
			h# 00d046 of kOUI_Dolby      endof  \ Dolby
			h# 00e047 of kOUI_InFocus    endof  \ InFocus
			h# ca125c of kOUI_Microsoft  endof  \ Microsoft
			h# 0012FA of kOUI_THX        endof  \ THX   
			h# 1abbfb of kOUI_UHDA       endof  \ UHD Alliance
			h# 3a0292 of kOUI_VESA       endof  \ VESA
			dup       of 0               endof
		endcase
		;

	: parse-cta-block ( allmodes? cta_block display_info -- done? )
		" [ parse-cta-block " .dbg 2 pick .d over 8 u.r dup space 8 u.r cr
		swap															\ allmodes? display_info cta_block
		c@++ swap dup 1f and swap 5 >> over 0>	over 7 = and if			\ allmodes? display_info cta_block++ len=byte0&1f tag=byte0>>5 ( len>0&&tag==7 -- )
			8 << rot c@++ -rot or rot 1- swap							\ allmodes? display_info cta_block++ len-- tag=(tag<<8)|exttag
		then															\ allmodes? display_info cta_block len tag

		dup 3 = over h# 701 = or over h# 711 = or 2 pick 3 >= and if	\ allmodes? display_info cta_block len tag ( (tag==3||tag==701||tag=711)&&(len>=3) -- )
			2 pick 3c@-le oui-num or									\ allmodes? display_info cta_block len tag|=oui-num
			rot 3 + rot 3 - rot											\ allmodes? display_info cta_block+=3 len-=3 tag
		then															\ allmodes? display_info cta_block len tag

		" tag:" .dbg dup . 2 pick 2 pick .hexstring cr					\ allmodes? display_info cta_block len tag ( cta_block len -- )

		case															\ allmodes? display_info cta_block len tag
			2 of														\ allmodes? display_info cta_block len
			
			
			endof

			3 kOUI_HDMI + of
			
			
			endof
			
			h# 70e of													\ allmodes? display_info cta_block len
			
			
			
			endof
			
			
			h# 722 of													\ allmodes? display_info cta_block len
			
			
			endof
			
			
			h# 723 of													\ allmodes? display_info cta_block len
			
			
			endof
			
			h# 72a of													\ allmodes? display_info cta_block len
			
			
			endof

		endcase															\ allmodes? display_info cta_block len

		2drop 2drop false
		" ] parse-cta-block" .dbg cr
		;

	: loop-timings-edid ( edid-addr edid-size allmodes? display-info -- )
\ ." 1:" .stack \ edid-addr=FF8D8F80 edid-size=128 allmodes?=true display-info=FF8666B0
		" [ loop-timings-edid" .dbg cr
		d# 700 to current-edid-mode-number
\ ." 2:" .stack \  edid-addr=FF8D8F80edid-size=128 allmodes?=true display-info=FF8666B0
		2swap bounds ?do												\ allmodes? display_info
			i c@ case													\ allmodes? display_info tag
				0 of \ base												\ allmodes? display_info
					" [ base block" .dbg cr

\ ." 3:" .stack \ allmodes?=true display-info=FF8666B0
					over i >edid.established-timings					\ allmodes? display_info allmodes? et_bits
					established-timings-i-and-ii 3 pick					\ allmodes? display_info allmodes? et_bits table display_info
					parse-established-timings ( allmodes? et_bits table display_info -- done? )
					if													\ allmodes? display_info
						unloop 2drop									\
						" ] loop-timings-edid established-timings done" .dbg cr
						exit											\
					then

\ ." 4:" .stack \ FF8666B0 FF8666B0 FF8666B0 FFFFFFFF FF8666B0 FF8D8FA3
					i >edid.standard-timings d# 16 2 pick				\ allmodes? display_info std_timings 16 display_info
					calc-standard-timings ( std_timings size display-info -- done? )
					if													\ allmodes? display_info
						2drop
						" ] loop-timings-edid standard-timings done" .dbg cr
						exit
					then												\ allmodes? display_info

\ ." 9:" .stack
					i >edid.display-descriptors d# 72 bounds do			\ allmodes? display_info
						over i 2 pick parse-detailed-timing-descriptor	\ allmodes? display_info ( allmodes? descriptor display_info -- done? )
						if												\ allmodes? display_info
							unloop 2drop								\
							" ] loop-timings-edid display-descriptors done" .dbg cr
							exit										\
						then											\ allmodes? display_info
					/dtd +loop

					" ] base block" .dbg cr
				endof

				2 of \ cta													\ allmodes? display_info
					" [ cta block" .dbg cr
					\ .stack \ FFFFFFFF FF84F9C0

					i 2+ c@	dup 4 d# 127 between if							\ allmodes? display_info offset ( between(offset, 4, 127) -- )
						\ .stack \ FFFFFFFF FF84F9C0 0000003B
						i 1+ c@ 3 >= if										\ allmodes? display_info offset ( version >= 3 -- )
							" [ cta-blocks" .dbg cr
							4												\ allmodes? display_info offset cta_block
							begin
								dup i + c@ 1f and 1+						\ allmodes? display_info offset cta_block block_len=((i[cta_block] & 0x1f) + 1)
								3dup + >=									\ allmodes? display_info offset cta_block block_len offset>=cta_block+block_len
							while											\ allmodes? display_info offset cta_block block_len
								4 pick 2 pick i + 5 pick parse-cta-block	\ allmodes? display_info offset cta_block block_len ( allmodes? cta_block display_info -- done? )
								if											\ allmodes? display_info offset cta_block block_len
									unloop 2drop 3drop						\ allmodes? display_info offset cta_block block_len
									" ] loop-timings-edid cta-blocks done" .dbg cr
									exit									\
								then										\ allmodes? display_info offset cta_block block_len
								+											\ allmodes? display_info offset cta_block+=block_len
								\ .stack \ FFFFFFFF FF84F9C0 0000003B 0000003B
																			\ allmodes? display_info offset cta_block
							repeat											\ allmodes? display_info offset cta_block block_len
							2drop											\ allmodes? display_info offset
							" ] cta-blocks" .dbg cr
							\ .stack
						then												\ allmodes? display_info offset

						" [ detailed-timings" .dbg cr
						dup i + swap d# 110 swap - 0 max bounds ?do			\ allmodes? display_info start=offset+i max(127-18+1-offset, 0)
							\ .stack
							over i 2 pick parse-detailed-timing-descriptor	\ allmodes? display_info ( allmodes? descriptor display_info -- done? )
							if												\ allmodes? display_info
								unloop 2drop
								" ] loop-timings-edid cta display-descriptors done" .dbg cr
								exit
							then											\ allmodes? display_info
						/dtd +loop											\ allmodes? display_info
						" ] detailed-timings" .dbg cr
						\ .stack
					then													\ allmodes? display_info
					" ] cta block" .dbg cr
				endof														\ allmodes? display_info

				h# 10 of \ vtb
					" [ vtb block" .dbg cr

					\ •

					" ] vtb block" .dbg cr
				endof

				h# 70 of \ displayid									\ allmodes? display-info
					" [ displayid block" .dbg cr

					\ •

					" ] displayid block" .dbg cr
				endof

				\ default
					" [ ignored block" .dbg dup . cr

					\ •

					" ] ignored block" .dbg dup . cr

			endcase														\ allmodes? display-info
		/edid-base +loop
		2drop
		" ] loop-timings-edid" .dbg cr
		;

	: calc-refresh-rate ( display-timing -- refresh-rate_hundredths )
		>r																\ R: display-timing
		r@ >T.pixel-clock l@											\ pixel-clock \ R: display-timing
		r@ >T.interlaced c@												\ pixel-clock interlaced \ R: display-timing
		if d# 2000 else d# 1000 then									\ pixel-clock multiply \ R: display-timing
		um*																\ pixel_clock^*10*100 hi \ R: display-timing
		r@ >T.htotal w@													\ pixel_clock^*10*100 hi htotal \ R: display-timing
		r> >T.vtotal w@													\ pixel_clock^*10*100 hi htotal vtotal
		*																\ pixel_clock^*10*100 hi total
		um/round														\ refresh-rate_hundredths
		;

	: dump-display-timing ( display_timing -- )
		base @ decimal swap										\ base display_timing
		." ("
		dup    >T.mode w@ 0 <# #s #> type
		." ) "
		dup >T.hactive w@ 0 <# #s #> type ."  x "				\ base display_timing
		dup >T.vactive w@ 0 <# #s #> type						\ base display_timing
		dup >T.interlaced c@ if ." i" then						\ base display_timing
		."  @ "													\ base display_timing
		dup calc-refresh-rate									\ base display_timing refresh_rate_hundredths
		0														\ base display_timing refresh_rate_hundredths hi
		\ digits are pictured from right to left
		<# # # [char] . hold #s #> type							\ base display_timing
		."  Hz"													\ base display_timing
		>T.note													\ base note
		dup c@ if												\ base note
			."  ("												\ base note
			begin												\ base note
				dup c@ ?dup										\ base note *note
			while
				emit											\ base note
				1+												\ base note++
			repeat												\ base note
			." )"												\ base note
		then													\ base note
		drop													\ base
		base !													\ base
		;

	: dump-display-timing-cr ( display-timing display-info -- done? )
		>T.mode w@ over >T.mode w@ = if							\ display-timing
			." (*) "
		else
			."     "
		then
		dump-display-timing cr false
		;

	\ ====================================================================================
	\ Words

	: map-in    " map-in"    $call-parent ; ( phys.low phys.mid phys.hi size -- virt )
	: map-out   " map-out"   $call-parent ; ( virt size -- )
	: config-l@ " config-l@" $call-parent ; ( config-addr -- data )
	: config-l! " config-l!" $call-parent ; ( data config-addr -- )

	: my-config-l@ ( reg -- x )
		parent-space or config-l@ ;

	: my-config-l! ( x reg -- )
		parent-space or config-l! ;

	\ Get the BAR value, check the size, and restore the BAR value
	: get-bar-size ( bar -- size )
		parent-space or dup config-l@ swap -1 over config-l! dup config-l@ -10 and negate -rot config-l! ;

	\ ====================================================================================
	\ DingusVideo parent

	" get bar sizes" .dbg cr

	10 get-bar-size constant vram-size
	30 get-bar-size constant rombar-size

	\ 42xxxxxxxx = relocatable, prefetchable, 32-bit memory space
	\ I/O shouldn't be prefetchable but we're an emulated device so we don't care.
	\ We must map-in the entire BAR, otherwise map-in might try to assign an unaligned physical address to the BAR.
	my-address parent-space h# 42000010 or vram-size
	.stack
	" map-in bar 10" .dbg cr
	map-in
	.stack
	value vram-base
	vram-base >M.num-displays l@ constant num-displays

	\ map-out may be really slow for large BARs like 256 MB.
	vram-base vram-size
	.stack
	" map-out bar 10" .dbg cr
	map-out
	.stack
	-1 to vram-base

	num-displays /display-regs * /meta-regs + h# FFF + h# -1000 and constant all-regs-size
	vram-size all-regs-size - num-displays / h# -1000 and constant vram-per-display

	" rombar-size: " .dbg rombar-size . cr
	" vram-size: " .dbg vram-size . cr
	" num-displays: " .dbg num-displays . cr
	" meta-regs-size: " .dbg /meta-regs . cr
	" display-regs-size: " .dbg /display-regs . cr
	" all-regs-size: " .dbg all-regs-size . cr
	" vram-per-display: " .dbg vram-per-display . cr

	" setting reg" .dbg cr
	.stack

	my-address parent-space                encode-phys         0 encode-int encode+ 0           encode-int encode+ \ config space
	my-address parent-space h# 42000010 or encode-phys encode+ 0 encode-int encode+ vram-size   encode-int encode+ \ prefetchable, relocatable, 32-bit memory space
	my-address parent-space h# 02000030 or encode-phys encode+ 0 encode-int encode+ rombar-size encode-int encode+ \               relocatable, 32-bit memory space
	" reg" property

	30 my-config-l@ value rombar-old
	" old rombar: " .dbg rombar-old 8 u.r cr

	my-address parent-space h# 02000030 or rombar-size
	.stack
	" map-in rom" .dbg cr
	map-in value rom-base
	30 my-config-l@ 1 or dup " new rombar: " .dbg 8 u.r cr 30 my-config-l!
	" [ rom-mapped" .dbg cr
	.stack

	" rom-base: " .dbg rom-base 8 u.r cr

	defer my-parse-1hex
	false value has-unit-address

	" looking for parse-1hex" .dbg cr

	" parse-1hex" $def-find if
		" found it; setting decode-unit" .dbg cr
		to my-parse-1hex
		1 encode-int " #address-cells" property
		0 encode-int " #size-cells" property
		" : decode-unit parse-1hex ;" evaluate
		true to has-unit-address
	else
		2drop
	then
	.stack

	\ ========================================================================================
	\ Display words

\ >D.mon-sense (9 bits) interpretation (from control.of)
\
\ bits 8,7,6: 3 bits levels in  : 0 pull low, 1 = float high    l2.l1.l0
\ bits 5,4,3: 3 bits dirs       : 1 = input , 0 = output        d2.d1.d0 \ opposite of ATI
\ bits 2,1,0: 3 bits levels out : 0 pull low, 1 = float high    l2.l1.l0
\
\ l2 = sense 2 = SDA data
\ l1 = sense 1 = SCL clock
\ l0 = sense 0

	: get-mon-sense ( display-info -- )
		" [ get-mon-sense" .dbg cr

		dup >I.display-regs l@ >D.mon-sense								\ display_info &sense

		o# 70 over l! \ d2=1,d1=1,d0=1 \ disable outputs				\ display_info &sense
		dup l@ 2 << h# 700 and \ move bits 8,7,6 to 10,9,8				\ display_info &sense code=(sense<<2)&0x700

		over o# 30 swap l! \ d2=0,l2=0 \ set sense-2 low				\ display_info &sense code=(sense<<2)&0x700
		over l@ 2 >> b# 110000 and or \ move bits 7,6 to 5,4			\ display_info &sense code=((sense<<2)&0x700)|((sense>>2)&0b110000)

		over o# 50 swap l! \ d1=0,l1=0 \ set sense-1 low				\ display_info &sense code=((sense<<2)&0x700)|((sense>>2)&0b110000)
		\ move bits 8,6 to 3,2
		over l@ dup 4 >> b# 000100 and swap 5 >> b# 001000 and or or	\ display_info &sense code=((sense<<2)&0x700)|((sense>>2)&0b110000)|((sense>>4)&0b000100)|((sense>>5)&0b001000)

		over o# 60 swap l! \ d0=0,l0=0 \ set sense-0 low				\ display_info &sense code=((sense<<2)&0x700)|((sense>>2)&0b110000)|((sense>>4)&0b000100)|((sense>>5)&0b001000)
		over l@ 7 >> b# 000011 and or \ move bits 8,7 to 1,0			\ display_info &sense code=((sense<<2)&0x700)|((sense>>2)&0b110000)|((sense>>4)&0b000100)|((sense>>5)&0b001000)|((sense>>7)&0b000011)

		swap o# 70 swap l! \ d2=1,d1=1,d0=1 \ disable outputs			\ display_info code

		over >I.sense-code over swap w!									\ display_info code

		get-sense-code-entry ?dup if									\ display_info entry
			>S.monochrome w@											\ display_info mono
			over >I.mono-mode? c!										\ display_info
		then															\ display_info

		" ] get-mon-sense 0x" .dbg >I.sense-code w@ . cr				\
		;

	: valid-edid-checksum? ( addr -- valid? )
		" [ valid-edid-checksum?" .dbg cr
		0 swap /edid-base bounds do i c@ + loop 0ff and 0=
		" ] valid-edid-checksum? " .dbg dup . cr
		;

	: base-block-valid? ( addr -- valid? )
		" [ base-block-valid?" .dbg cr
		" "(00FFFFFFFFFFFF00)" comp 0= ( addr1 addr2 len -- ?diff? )
		\ We could also check for other stuff such as:
		\ - EDID version number (should be 1)
		\ - EDID checksum
		" ] base-block-valid? " .dbg dup . cr
		;

	: write-sense-dirs-levels ( d2.d1.d0.l2.l1.l0 display-info -- )
		swap
		\ d2.d1.d0: 0 = input, 1 = output
\		" [ write-sense-dirs-levels" .dbg ."  dirs:" dup 3 >> . ." levels:" dup 7 and . cr
		o# 70 xor
		swap
		>I.display-regs l@ >D.mon-sense l!
\		" ] write-sense-dirs-levels" .dbg cr
		;

	: read-sense-dirs-levels \ ( display-info -- (00.d2.d1.d0.l2.l1.l0) )
		\ d2.d1.d0: 0 = input, 1 = output
\		" [ read-sense-dirs-levels" .dbg cr
		>I.display-regs l@ >D.mon-sense l@
		o# 70 xor
		dup 6 >> 7 and swap o# 70 and or \ d2.d1.d0.l2.l1.l0
\		" ] read-sense-dirs-levels" .dbg ."  dirs:" dup 3 >> . ." levels:" dup 7 and . cr
		;

	: read-scl ( display-info -- SCL )
\		" [ read-scl" .dbg cr
		read-sense-dirs-levels											\ (00.d2.d1.d0.l2.l1.l0)
		2 and															\ l1=((00.d2.d1.d0.l2.l1.l0)&2
		0<>																\ SCL=l1!=0
\		" ] read-scl " .dbg dup . cr
		;

	: read-sda ( display-info -- SDA )
\		" [ read-sda" .dbg cr
		read-sense-dirs-levels											\ (00.d2.d1.d0.l2.l1.l0)
		4 and															\ l2=(00.d2.d1.d0.l2.l1.l0)&4
		0<>																\ SDA=(l2!=0)
\		" ] read-sda " .dbg dup . cr
		;

	: wait-16th-ms
		\ emulated display doesn't need to wait
		;

	: set-scl-high-and-confirm ( display-info -- )
		\ waiting is required to support target clock stretching
		\ wait up to one millisecond
\		" [ set-scl-high-and-confirm" .dbg cr
		d# 16 0 do														\ display_info
\			" [ set-scl-high-and-confirm i:" .dbg i . cr
			dup read-sense-dirs-levels									\ display_info (00.d2.d1.d0.l2.l1.l0)
			o# 22														\ display_info (00.d2.d1.d0.l2.l1.l0) \o2.2
			or over														\ display_info (00.d2.1.d0.l2.1.l0) display_info \ SCLdir=Out SCL=high
			write-sense-dirs-levels										\ display_info
			dup read-scl												\ display_info SCL
			if															\ display_info
\				" ] set-scl-high-and-confirm i:" .dbg i . ." succeed!" cr
				leave													\ display_info
			else														\ display_info
				wait-16th-ms											\ display_info
			then														\ display_info
\			" ] set-scl-high-and-confirm i:" .dbg i . cr
		loop															\ display_info
		drop															\
\		" ] set-scl-high-and-confirm" .dbg cr
		;

	: clock-edid-bit-scl-high-and-wait ( display-info -- )
		\ waiting is required to support target clock stretching
\		" [ clock-edid-bit-scl-high-and-wait" .dbg cr
		set-scl-high-and-confirm										\
		wait-16th-ms													\
\		" ] clock-edid-bit-scl-high-and-wait" .dbg cr
		;

	: set-scl-low ( display-info -- )
\		" [ set-scl-low" .dbg cr
		dup read-sense-dirs-levels										\ display_info (00.d2.d1.d0.l2.l1.l0)
		o# 20															\ display_info (00.d2.d1.d0.l2.l1.l0) \o2.0
		or																\ display_info (00.d2.1.d0.l2.l1.l0) \ SCLdir=Out
		o# 75															\ display_info (00.d2.1.d0.l2.l1.l0) \o7.5 \ SCLdir=Out
		and																\ display_info (00.d2.1.d0.l2.0.l0) \ SCLdir=Out SCL=low
		swap write-sense-dirs-levels									\
\		" ] set-scl-low" .dbg cr
		;

	: unclock-edid-bit-scl-low-and-wait ( display-info -- )
\		" [ unclock-edid-bit-scl-low-and-wait" .dbg cr
		set-scl-low ( display-info -- )									\
		wait-16th-ms													\
\		" ] unclock-edid-bit-scl-low-and-wait" .dbg cr
		;

	: set-scl-in ( display-info -- )
\		" [ set-scl-in" .dbg cr
		dup read-sense-dirs-levels										\ display_info (00.d2.d1.d0.l2.l1.l0)
		o# 57															\ display_info (00.d2.d1.d0.l2.l1.l0) \o5.7
		and																\ display_info (00.d2.0.d0.l2.l1.l0) \ SCLdir=In
		swap write-sense-dirs-levels									\
\		" ] set-scl-in" .dbg cr
		;

	: set-sda-high ( display-info -- )
\		" [ set-sda-high" .dbg cr
		dup read-sense-dirs-levels										\ display_info (00.d2.d1.d0.l2.l1.l0)
		o# 44															\ display_info (00.d2.d1.d0.l2.l1.l0) \o4.4
		or																\ display_info (00.1.d1.d0.1.l1.l0) \ SDAdir=Out SDA=1
		swap write-sense-dirs-levels									\
\		" ] set-sda-high" .dbg cr
		;

	: send-1-bit-and-wait ( display-info -- )
\		" [ send-1-bit-and-wait" .dbg cr
		set-sda-high													\
		wait-16th-ms													\
\		" ] send-1-bit-and-wait" .dbg cr
		;

	: set-sda-low ( display-info -- )
\		" [ set-sda-low" .dbg cr
		dup read-sense-dirs-levels										\ display_info (00.d2.d1.d0.l2.l1.l0)
		o# 40															\ display_info (00.d2.d1.d0.l2.l1.l0) \o4.0
		or																\ display_info (00.1.d1.d0.l2.l1.l0)
		o# 73															\ display_info (00.1.d1.d0.l2.l1.l0) \o7.3
		and																\ display_info (00.1.d1.d0.0.l1.l0) \ SDAdir=Out SDA=0
		swap write-sense-dirs-levels
\		" ] set-sda-low" .dbg cr
		;

	: set-sda-in ( display-info -- )
\		" [ set-sda-in" .dbg cr
		dup read-sense-dirs-levels										\ display_info (00.d2.d1.d0.l2.l1.l0)
		o# 37															\ display_info (00.d2.d1.d0.l2.l1.l0) \o3.7
		and																\ display_info (00.0.d1.d0.l2.l1.l0) \ SDAdir=In
		swap write-sense-dirs-levels
\		" ] set-sda-in" .dbg cr
		;

	: scl-low-then-high-until-scl-and-sda-high ( display-info -- )
\		" [ scl-low-then-high-until-scl-and-sda-high" .dbg cr
		\ original has loop 256 times
		d# 16 0 do														\ display_info
\			" [ scl-low-then-high-until-scl-and-sda-high i:" .dbg i . cr
			dup set-sda-in ( display-info -- )							\ display_info
			dup set-scl-in ( display-info -- )							\ display_info
			wait-16th-ms												\ display_info
			dup read-scl ( display-info -- SCL )						\ display_info SCL
			over read-sda ( display-info -- SDA )						\ display_info SCL SDA
			and if														\ display_info
\				" ] scl-low-then-high-until-scl-and-sda-high i:" .dbg i . ." succeed!" cr
				leave													\ display_info
			then														\ display_info
			dup unclock-edid-bit-scl-low-and-wait						\ display_info
			dup clock-edid-bit-scl-high-and-wait						\ display_info
\			" ] scl-low-then-high-until-scl-and-sda-high i:" .dbg i . cr
		loop
		drop
\		" ] scl-low-then-high-until-scl-and-sda-high" .dbg cr
		;

	: wait-for-idle-then-send-start-bit ( display-info -- )
\		" [ wait-for-idle-then-send-start-bit" .dbg cr
		dup scl-low-then-high-until-scl-and-sda-high					\ display_info
		dup set-sda-low ( display-info -- )								\ display_info
		wait-16th-ms													\ display_info
		dup set-scl-low ( display-info -- )								\ display_info
		set-sda-in ( display-info -- )									\
		wait-16th-ms													\
\		" ] wait-for-idle-then-send-start-bit" .dbg cr
		;

	: send-stop-until-idle ( display-info -- )
\		" [ send-stop-until-idle" .dbg cr
		\ original has loop 256 times
		d# 16 0 do
\			" [ send-stop-until-idle i:" .dbg i . cr
			dup unclock-edid-bit-scl-low-and-wait						\ display_info
			dup set-sda-low ( display-info -- )							\ display_info
			wait-16th-ms
			dup clock-edid-bit-scl-high-and-wait						\ display_info
			dup send-1-bit-and-wait										\ display_info
			dup set-sda-in ( display-info -- )							\ display_info
			dup set-scl-in ( display-info -- )							\ display_info
			\ 3 ms \ we don't need to wait
			dup read-scl ( display-info -- SCL )						\ display_info SCL
			over read-sda ( display-info -- SDA )						\ display_info SCL DDA
			and if														\ display_info
\				" ] send-stop-until-idle i:" .dbg i . ." succeed!" cr
				leave													\ display_info
			then														\ display_info
\			" ] send-stop-until-idle i:" .dbg i . cr
		loop															\ display_info
		drop															\
\		" ] send-stop-until-idle" .dbg cr
		;

	: send-a-bit ( thebit display-info -- )
\		" [ send-a-bit " .dbg over 80 and 0<> . cr
		swap h# 80 and if												\ display_info
			dup set-sda-high											\ display_info
		else															\ display_info
			dup set-sda-low ( display-info -- )							\ display_info
		then															\ display_info
		dup clock-edid-bit-scl-high-and-wait							\ display_info
		dup set-scl-low ( display-info -- )								\ display_info
		set-sda-in ( display-info -- )									\
		wait-16th-ms													\
\		" ] send-a-bit" .dbg cr
		;

	: read-a-bit ( display-info -- thebit )
\		" [ read-a-bit" .dbg cr
		dup set-sda-in ( display-info -- )								\ display_info
		dup clock-edid-bit-scl-high-and-wait							\ display_info
		dup read-sda ( display-info -- SDA )							\ display_info SDA
		swap unclock-edid-bit-scl-low-and-wait							\ SDA display_info
\		" ] read-a-bit " .dbg dup . cr
		;

	: send-address-wait-for-ack ( address display-info -- ack'd )
\		" [ send-address-wait-for-ack " .dbg over . cr
\		" [ send-address " .dbg over . cr
		swap 8 0 do														\ display_info address
\			" [ send-address bit:" .dbg i . cr
			2dup swap													\ display_info address address display_info
			send-a-bit ( thebit display-info -- )						\ display_info address
			2*															\ display_info address<<=1
\			" ] send-address bit:" .dbg i . cr
		loop															\ display_info address
\		" ] send-address" .dbg cr
		drop															\ display_info
		0 \ ack'd = false												\ display_info ack'd=false
		\ original has loop 256 times
		d# 16 0 do														\ display_info ack'd=false
\			" [ wait-for-ack i:" .dbg i . cr
			over read-a-bit 0= ( display-info -- thebit )				\ display_info ack'd=false thebit==0
			if															\ display_info ack'd=false
				0= \ return ack'd = true								\ display_info ack'd=true
\				" ] wait-for-ack i:" .dbg i . ." succeed!" cr
				leave													\ display_info ack'd=true
			then														\ display_info ack'd
\			" ] wait-for-ack i:" .dbg i . cr
		loop															\ display_info ack'd
		nip																\ ack'd
\		" ] send-address-wait-for-ack " .dbg dup . cr
		;

	: read-edid-byte-and-ack ( display-info -- byte )
\		" [ read-edid-byte-and-ack" .dbg cr
		dup set-sda-in ( display-info -- )								\ display_info
		0 8 0 do														\ display_info bits=0
\			" [ read-edid-byte bit:" .dbg i . cr
			2*															\ display_info bits<<=1
			over clock-edid-bit-scl-high-and-wait						\ display_info bits display_info
			over read-sda ( display-info -- SDA )						\ display_info bits SDA
			1 and +														\ display_info bits+=SDA
			over unclock-edid-bit-scl-low-and-wait						\ display_info bits
\			" ] read-edid-byte bit:" .dbg i . cr
		loop															\ display_info bits
		0 rot send-a-bit ( thebit display-info -- )						\ bits
\		" ] read-edid-byte-and-ack " .dbg dup . cr
		;

	: set-sub-address-to-zero-get-ack-send-stop ( display-info -- ack'd )
\		" [ set-sub-address-to-zero-get-ack-send-stop" .dbg cr
		0																			\ display_info ack'd=false
		over wait-for-idle-then-send-start-bit ( display-info -- )					\ display_info ack'd
		0a0 2 pick send-address-wait-for-ack ( address display-info -- ack'd )		\ display_info ack'd ack'd
		if																			\ display_info ack'd
			0 2 pick send-address-wait-for-ack ( address display-info -- ack'd )	\ display_info ack'd ack'd
			if																		\ display_info ack'd
				drop -1																\ display_info ack'd=true
			then																	\ display_info ack'd
		then																		\ display_info ack'd
		swap send-stop-until-idle ( display-info -- )								\ ack'd
\		" ] set-sub-address-to-zero-get-ack-send-stop " .dbg dup . cr
		;

	: read-block ( addr display-info -- success? )
		" [ read-block" .dbg cr
		swap															\ display-info addr
		\ fill with odd number to ensure invalid checksum
		dup /edid-base ef fill ( addr len byte -- )						\ display-info addr

		/edid-base 0 do (  -- success? )
\			" [ read-edid byte " .dbg i . cr
			over read-edid-byte-and-ack ( display-info -- byte )		\ display-info addr c
			swap c!++ ( val adr -- adr+1 )								\ display-info *addr++=c
\			" ] read-edid byte " .dbg i . cr
		loop															\ display-info addr
		2drop true														\ true
		" ] read-block " .dbg dup . cr
		;

	: supports-ddc ( display-info -- supportsDDC )
		.stack
		" [ supports-ddc" .dbg cr										\ display_info
		dup set-scl-low ( display-info -- )								\ display_info
		\ 20 ms \ don't need delays for emulated displays
		0 \ supportsDDC = false											\ display_info supportsDDC=false
		over scl-low-then-high-until-scl-and-sda-high					\ display_info supportsDDC
		over set-scl-in ( display-info -- )								\ display_info supportsDDC
		over set-sda-in ( display-info -- )								\ display_info supportsDDC
		\ 3 ms \ don't need delays for emulated displays
		over read-scl ( display-info -- SCL )							\ display_info supportsDDC SCL
		2 pick read-sda ( display-info -- SDA )							\ display_info supportsDDC SCL SCA
		and if \ SCL and SDA are idled (both high)						\ display_info supportsDDC
			over set-scl-low ( display-info -- )						\ display_info supportsDDC
			wait-16th-ms												\ display_info supportsDDC
			over read-sda ( display-info -- SDA )						\ display_info supportsDDC SDA
			if \ SDA is separate from SCL and does not respond to SCL going low
				over set-scl-in ( display-info -- )						\ display_info supportsDDC
				over set-sda-low ( display-info -- )					\ display_info supportsDDC
				wait-16th-ms
				over read-scl ( display-info -- SCL )					\ display_info supportsDDC SCL
				if \ SCL is separate from SDA and does not respond to SDA going low
					1 0 do												\ display_info supportsDDC
						" [ supports-ddc set-sub-address-to-zero-get-ack-send-stop i:" .dbg i . cr
						over set-sub-address-to-zero-get-ack-send-stop ( display-info -- ack'd )
						if												\ display_info supportsDDC
							drop -1 \ supportsDDC = true				\ display_info supportsDDC=true
							" ] supports-ddc set-sub-address-to-zero-get-ack-send-stop i:" .dbg i . ." succeed!" cr
							leave
						then
						" ] supports-ddc set-sub-address-to-zero-get-ack-send-stop i:" .dbg i . cr
					loop
				then
			then
		then															\ display_info supportsDDC
		" ] supports-ddc " .dbg dup . cr
		nip																\ supportsDDC
		.stack
		;

	: read-edid ( display-info -- )
		" [ read-edid" .dbg cr													\ display_info
		dup >I.edid l@ ?dup if													\ display_info display_info.edid
			over >I.edid-size w@												\ display_info display_info.edid display_info.edid_size
			free-mem ( a-addr len -- )											\ display_info
			0 over >I.edid l!													\ display_info
			0 over >I.edid-size w!												\ display_info
		then																	\ display_info

		dup supports-ddc 0= if ( display-info -- supportsDDC )					\ display_info
			drop																\
			" ] read-edid supports-ddc: false" .dbg cr
			exit
		then

		dup wait-for-idle-then-send-start-bit ( display-info -- )				\ display_info
		0a1 \ read from 50h which is EDID										\ display_info 0xa1
		over send-address-wait-for-ack ( address display-info -- ack'd )		\ display_info ack'd
		if
			/edid-base alloc-mem ( len -- a-addr )								\ display_info edid_base
			2dup swap read-block ( addr display-info -- success? )				\ display_info edid_base success?
			over base-block-valid? and 0= if									\ display_info edid_base
				/edid-base free-mem												\ display_info
				drop															\ display_info
				" ] read-edid base-block-valid?: false" .dbg cr
				exit															\
			then																\ display_info edid_base
			dup >edid.number-of-extensions c@									\ display_info edid_base num_extensions
			dup /edid-base tuck * +												\ display_info edid_base num_extensions edid_size=128+num_extensions*128
			dup alloc-mem ( len -- a-addr )										\ display_info edid_base num_extensions edid_size edid

			3 pick over	/edid-base move ( src-addr dest-addr len -- )			\ display_info edid_base num_extensions edid_size edid
			3 roll /edid-base free-mem ( a-addr len -- )						\ display_info num_extensions edid_size edid

			dup >edid.next-block 3 roll 0 ?do									\ display_info edid_size edid block
				dup 4 pick read-block 0= if leave then							\ display_info edid_size edid block
				>edid.next-block												\ display_info edid_size edid block+=128
			loop																\ display_info edid_size edid edid_end

			over -																\ display_info edid_size edid read_size=edid_end-edid
			rot 2dup <> if														\ display_info edid read_size edid_size
				over alloc-mem ( len -- a-addr )								\ display_info edid read_size edid_size new_edid
				3 pick over 4 pick move ( src-addr dest-addr len -- )			\ display_info edid read_size edid_size new_edid
				3 roll rot free-mem ( a-addr len -- )							\ display_info read_size new_edid
			else																\ display_info edid read_size edid_size
				nip swap														\ display_info edid_size edid
			then																\ display_info edid_size edid

			2 pick >I.edid l!													\ display_info edid_size
			over >I.edid-size w!												\ display_info

			dup p-edid-monochrome? ( display-info -- monochrome? )				\ display_info monochrome
			over >I.mono-mode? c!												\ display_info
		then																	\ display_info
		send-stop-until-idle ( display-info -- )								\ display_info
		" ] read-edid" .dbg cr													\
		;

	: loop-timings-all ( display-info -- )
		all-display-timings												\ display_info modeptr
		begin															\ display_info modeptr
			dup l@ ?dup													\ display_info modeptr mode mode
		while															\ display_info modeptr mode
			2 pick														\ display_info modeptr mode display_info
			timing-proc													\ display_info modeptr done?
			if															\ display_info modeptr
				2drop exit												\
			then														\ display_info modeptr
			la1+														\ display_info modeptr++
		repeat															\ display_info modeptr
		drop															\ display_info

		dup >I.edid l@ ?dup if											\ display_info edid
			over >I.edid-size w@ false 3 pick							\ display_info edid edid_size true display_info
			loop-timings-edid											\ display_info
		then															\ display_info
		drop															\ display_info
		;

	: loop-timings-display ( display-info -- )
		" [ loop-timings-display" .dbg cr
		.stack
		dup >I.edid l@ ?dup if											\ display_info edid
			over >I.edid-size w@ true 3 pick							\ display_info edid edid-size false display_info
			loop-timings-edid											\ display_info
			drop														\
			.stack
			" ] loop-timings-display EDID" .dbg cr
			exit
		then

		dup >I.sense-code w@ over										\ display_info sense-code display_info
		loop-timings-sense-code ( sense-code display-info -- )			\ display_info
		drop															\
		.stack
		" ] loop-timings-display sense" .dbg cr
		;

	: fits-in-vram? ( frame-buffer-bytes -- true|false )
		\ save 4K for hardware cursor
		vram-per-display h# 1000 -
		<=									\ frame-buffer-bytes < (vram-per-display - 0x1000)
		;

	: calc-row-bytes ( depth width -- row-bytes )
		* 7 + 8 / 7 + -8 and											\ (((width*depth + 7) / 8 + 7) & -8)
		;

	: is-valid-frame-buffer-bytes? ( depth width height -- framebytes )
		-rot															\ height depth width
		calc-row-bytes													\ height rowbytes
		*																\ (height * rowbytes)
		fits-in-vram?													\ valid?
		;

	: p-calc-row-bytes ( width display-info -- row-bytes )
		>I.pixel-depth c@ swap calc-row-bytes							\ rowbytes
		;

	: valid-timing? ( display-timing display-info -- isvalid? )
		over >T.width w@ swap p-calc-row-bytes			\ display-timing row-bytes
		swap >T.height w@ *								\ row-bytes frame-buffer-bytes
		fits-in-vram?									\ (frame-buffer-bytes <= vram-per-display)
		;

	create best-display-timing
	/display-timing allot

	: greatest-display-timing ( display-timing display-info -- done? )
		" [ greatest-display-timing ( display-timing display-info -- ) display-timing: " .dbg over dump-display-timing cr
		swap																	\ display_info new=display-timing
		best-display-timing >T.mode w@ if										\ display_info new
			best-display-timing													\ display_info new old
			\ accept = ( w> | ( w= & (h> | (h= & r< ) ) ) )
			over >T.width       w@ over >T.width       w@ 2dup > >r = >r		\ display_info new old \ R: (w> = (new.width>old.width)) (w= = (new.width==old.width))
			over >T.height      w@ over >T.height      w@ 2dup > >r = >r		\ display_info new old \ R: w> w= (h> = (new.height>old.height)) (h= = (new.height==old.height))
			over calc-refresh-rate over calc-refresh-rate <						\ display_info new old (r< = new.refresh-rate < old.refresh-rate) \ R: w> w= h> h=
			nip																	\ display_info new r< \ R: w> w= h> h=
			r> and r> or r> and	r> or and										\ display_info (new & ( ( ( ( r< & h= ) | h> ) & w= ) | w> ))
		then																	\ display_info new|null
		?dup if																	\ display_info new
			2dup swap valid-timing? ( display-timing display-info -- isvalid? )	\ display_info new new display_info
			if																	\ display_info new
				dup best-display-timing /display-timing							\ display_info new new best-display-timing /display-timing
				move ( src-addr dest-addr len -- )								\ display_info new
			then																\ display_info new
			drop																\ display_info
		then																	\ display_info
		drop																	\
		" ] greatest-display-timing" .dbg cr
		false
		;

	\ colors for iso6429-1983-colors have values 0, 1/3, 2/3, 3/3
	create std-16
	\		black    blue  green  cyan   red   magenta brown white          - low intensity
		" "(000000 0000AA 00AA00 00AAAA AA0000 AA00AA AA5500 AAAAAA)" $c,
	\		grey    blue  green  cyan   red   magenta yellow white			- high intensity
		" "(555555 5555FF 55FF55 55FFFF FF5555 FF55FF FFFF55 FFFFFF)" $c,

	\ colors for 2 bit mode have values 0, 1/3, 2/3, 3/3
	create std-4
	\		black  dark   light  white
		" "(000000 555555 AAAAAA FFFFFF)" $c,

	\ colors for 1 bit mode have values 0, 3/3
	create std-2
	\		black    white
		" "(000000 FFFFFF)" $c,

	create std-gamma
		" "(00 05 09 0B 0E 10 13 15 17 19 1B 1D 1E 20 22 24)" $c,
		" "(25 27 28 2A 2C 2D 2F 30 31 33 34 36 37 38 3A 3B)" $c,
		" "(3C 3E 3F 40 42 43 44 45 47 48 49 4A 4B 4D 4E 4F)" $c,
		" "(50 51 52 54 55 56 57 58 59 5A 5B 5C 5E 5F 60 61)" $c,
		" "(62 63 64 65 66 67 68 69 6A 6B 6C 6D 6E 6F 70 71)" $c,
		" "(72 73 74 75 76 77 78 79 7A 7B 7C 7D 7E 7F 80 81)" $c,
		" "(81 82 83 84 85 86 87 88 89 8A 8B 8C 8C 8D 8E 8F)" $c,
		" "(90 91 92 93 94 95 95 96 97 98 99 9A 9B 9B 9C 9D)" $c,
		" "(9E 9F A0 A1 A1 A2 A3 A4 A5 A6 A6 A7 A8 A9 AA AB)" $c,
		" "(AB AC AD AE AF B0 B0 B1 B2 B3 B4 B4 B5 B6 B7 B8)" $c,
		" "(B8 B9 BA BB BC BC BD BE BF C0 C0 C1 C2 C3 C3 C4)" $c,
		" "(C5 C6 C7 C7 C8 C9 CA CA CB CC CD CD CE CF D0 D0)" $c,
		" "(D1 D2 D3 D3 D4 D5 D6 D6 D7 D8 D9 D9 DA DB DC DC)" $c,
		" "(DD DE DF DF E0 E1 E1 E2 E3 E4 E4 E5 E6 E7 E7 E8)" $c,
		" "(E9 E9 EA EB EC EC ED EE EE EF F0 F1 F1 F2 F3 F3)" $c,
		" "(F4 F5 F5 F6 F7 F8 F8 F9 FA FA FB FC FC FD FE FF)" $c,

	: clut@ ( addr -- r g b )
		l@ 8 << lbflip lbsplit drop	\ 0rgb \ rgb0 \ 0bgr \ r g b 0 \ r g b \
		;

	: clut!	( r g b addr -- )
		>r 0 bljoin lbflip 8 >> r> l! \ r g b 0 \ R: addr \ 0bgr \ rgb0 \ 0rgb \ 0rgb addr \
		;

	: ping-display ( immediate-flags display-info -- )
		" [ ping-display" .dbg cr
		>I.display-regs l@	\ immediate-flags regs
		>D.immediate-flags	\ immediate-flags &regs.immediate-flags
		l!					\
		" ] ping-display" .dbg cr
		;

	: reset-display ( display-info -- )
		" [ reset-display" .dbg cr
		dup >I.im-flags-to-set l@ h# 2 or swap	\ immediate-flags display_info
		ping-display
		" ] reset-display" .dbg cr
		;

	: p-.display-info ( display-info -- )
		cr
		dup >T.pixel-clock      l@ ." pixel-clock     : " .d cr

		dup >T.mode             w@ ." mode            : " .d cr
		dup >T.width            w@ ." width           : " .d cr
		dup >T.height           w@ ." height          : " .d cr

		dup >T.hactive          w@ ." hactive         : " .d cr
		dup >T.hsyncbegin       w@ ." hsyncbegin      : " .d cr
		dup >T.hsyncend         w@ ." hsyncend        : " .d cr
		dup >T.htotal           w@ ." htotal          : " .d cr

		dup >T.vactive          w@ ." vactive         : " .d cr
		dup >T.vsyncbegin       w@ ." vsyncbegin      : " .d cr
		dup >T.vsyncend         w@ ." vsyncend        : " .d cr
		dup >T.vtotal           w@ ." vtotal          : " .d cr

		dup >T.hpolarity        c@ ." hpolarity       : " .d cr
		dup >T.vpolarity        c@ ." vpolarity       : " .d cr
		dup >T.interlaced       c@ ." interlaced      : " .d cr
		dup >T.csyncdisabled    c@ ." csyncdisabled   : " .d cr

		dup >T.note                ." note            : ("	\ display_info note
			begin												\ display_info note
				dup c@ ?dup										\ display_info note *note *note
			while												\ display_info note *note
				emit											\ display_info note
				1+												\ display_info note++
			repeat												\ display_info note
			drop
			." )" cr

		dup >I.phandle          l@ ." phandle         : " 8 u.r cr
		dup >I.display-regs     l@ ." display-regs    : " 8 u.r cr
		dup >I.fb-base          l@ ." fb-base         : " 8 u.r cr
		dup >I.fb-address       l@ ." fb-address      : " 8 u.r cr
		dup >I.fb-row-bytes     l@ ." fb-row-bytes    : " .d cr
		dup >I.im-flags-to-set  l@ ." im-flags-to-set : " 8 u.r cr
		dup >I.open-count       l@ ." open-count      : " .d cr
		dup >I.edid             l@ ." edid            : " 8 u.r cr
		dup >I.edid-size        w@ ." edid-size       : " .d cr
		dup >I.sense-code       w@ ." sense-code      : " 4 u.r cr
		dup >I.mono-mode?       c@ ." mono-mode?      : " .d cr
		dup >I.pixel-depth      c@ ." pixel-depth     : " .d cr
		dup >I.display-number   c@ ." display-number  : " .d cr

		drop													\
		;

	: p-enable-display ( display-info -- )
		" [ p-enable-display" .dbg cr
		.stack
		dup >I.im-flags-to-set l@ h# 40 or swap	\ immediate-flags display_info
		ping-display
		.stack
		" ] p-enable-display" .dbg cr
		;

	: p-dimensions ( display-info -- width height )
		dup  >T.width  w@ \ display_info *(display_info.>T.width)
		swap >T.height w@ \ *(display_info+>T.width) *(display_info.>T.height)
		;

	: p-set-std-gamma ( display-info -- )
		" [ set-std-gamma ( display-info -- )" .dbg cr
			.stack
			>I.display-regs l@					\ regs
			h# 100 over >D.color-index l!		\ regs
			>D.color-data						\ &color-data
			100 0 do
				std-gamma i + c@ dup dup		\ &color-data val val val
				3 pick clut!					\ &color-data
			loop								\ &color-data
			drop
			.stack
		" ] set-std-gamma" .dbg cr
		;

	: p-set-colors ( adr index #indices display-info -- )
		" [ p-set-colors ( adr index #indices display-info -- )" .dbg cr
		.stack
		dup >I.display-regs l@					\ adr index #indices display_info regs
		dup " display-regs: " .dbg 8 u.r cr
		3 roll									\ adr #indices display_info regs index
		over >D.color-index						\ adr #indices display_info regs index &color-index
		l!										\ adr #indices display_info regs
		>D.color-data							\ adr #indices display_info &color-data
		swap >I.mono-mode? c@					\ adr #indices &color-data mono-mode?
		2swap									\ &color-data mono-mode? adr #indices
		( #indices ) 0 ?do						\ &color-data mono-mode? adr
			c@++ c@++ c@++ >r					\ &color-data mono-mode? r g b \ R: adr
			3 pick if							\ &color-data mono-mode? r g b \ R: adr
				h# 1c * swap					\ &color-data mono-mode? r b*1c g \ R: adr
				h# 97 * + swap					\ &color-data mono-mode? b*1c+g*97 r \ R: adr
				h# 4d * + 8 >>					\ &color-data mono-mode? luminance=(b*1c+g*97+r*4d)>>8 \ R: adr
				dup								\ &color-data mono-mode? r=luminance g=luminance \ R: adr
				dup								\ &color-data mono-mode? r=luminance g=luminance b=luminance \ R: adr
			then								\ &color-data mono-mode? r g b \ R: adr
			4 pick								\ &color-data mono-mode? r g b &color-data \ R: adr
			clut!								\ &color-data mono-mode? \ R: adr
			r>									\ &color-data mono-mode? adr
		loop									\ &color-data mono-mode? adr
		3drop									\
		.stack
		" ] p-set-colors" .dbg cr
		;

	: p-set-16-colors ( display-info -- )
		std-16 0 d# 16 3 roll p-set-colors ( adr index #indices display-info -- )
		;

	: p-set-2-colors ( display-info -- )
		std-2 0 d# 2 3 roll p-set-colors ( adr index #indices display-info -- )
		;

	: p-set-4-colors ( display-info -- )
		std-4 0 d# 4 3 roll p-set-colors ( adr index #indices display-info -- )
		;

	: p-get-colors ( adr index #indices display-info -- )
		>I.display-regs l@						\ adr index #indices regs
		dup >D.color-index						\ adr index #indices regs &color-index
		3 roll l!								\ adr #indices regs
		>D.color-data							\ adr #indices &color-data
		-rot									\ &color-data adr #indices
		( #indices ) 0 ?do						\ &color-data adr
			over clut@							\ &color-data adr r g b
			>r >r								\ &color-data adr r | R: b g
			swap c!++ r> swap c!++ r> swap c!++	\ &color-data adr+=3
		loop									\ &color-data adr
		2drop									\
		;

	variable rgb-temp

	: p-color! ( r g b index display-info -- )
		>r >r									\ r g b \ R: display_info index
		rgb-temp 2+ c!
		rgb-temp 1+ c!
		rgb-temp c!								\ R: display_info index
		rgb-temp r> 1 r>						\ adr index 1 display_info
		p-set-colors
		;

	: p-color@ ( index display-info -- r g b )
		>r rgb-temp swap 1 r>					\ adr index 1 display_info
		p-get-colors							\
		rgb-temp c@++ c@++ c@					\ r g b
		;

	: 32umod ( x - x%32 x/32 )
		dup 1f and swap 5 >> ;

	: p-set-pixel ( index x y display-info -- )
		dup >I.fb-row-bytes l@								\ index x y display_info row-bytes
		rot *												\ index x display_info row-bytes*y
		over >I.fb-address l@ +								\ index x display_info row-bytes*y+fb-address
		-rot												\ index lineaddr x display_info
		>I.pixel-depth c@ dup -1 swap d# 32 swap - tuck <<	\ index lineaddr x depth 32-depth -1<<32-depth
		2swap * d# 32 u/mod 4 *								\ index lineaddr 32-depth mask x*depth%32 x*depth/32*4
		4 roll + -rot tuck >> invert						\ index 32-depth addr x*depth%32 ~(mask >> x*depth%32)
		rot tuck l@	and										\ index 32-depth x*depth%32 addr ~(mask >> x*depth%32)&*addr
		2swap -	3 roll swap << or swap						\ ((~(mask >> x*depth%32)&*addr) | (index << (32-depth-x*depth%32))) addr
		l!													\
		;

	: rect-setup ( adr|index x y w h display-info -- w row-bytes adr|index xy-adr h )
		rot over >I.pixel-depth c@ tuck * 8 / swap	\ adr|index x y h display_info w*depth/8 depth
		rot dup >I.fb-row-bytes l@					\ adr|index x y h w*depth/8 depth display_info row-bytes
		swap >I.fb-address l@						\ adr|index x y h w*depth/8 depth row-bytes fbaddress
		over 6 roll * +								\ adr|index x h w*depth/8 depth row-bytes fbaddress+row-bytes*y
		rot 5 roll * 8 / +							\ adr|index h w*depth/8 row-bytes fbaddress+row-bytes*y+depth*x/8
		3 roll 4 roll -rot							\ w*depth/8 row-bytes adr|index fbaddress+row-bytes*y+depth*x/8 h
		;

	: p-draw-rectangle ( adr x y w h display-info -- )
		rect-setup								\ w row-bytes adr xy-adr h
		( h ) 0 ?do								\ w row-bytes adr xy-adr
			2dup 5 pick							\ w row-bytes adr xy-adr adr xy-adr w
			move ( src-addr dest-addr len -- )	\ w row-bytes adr xy-adr
			2over d+							\ w row-bytes adr+w xy-adr+row-bytes
		loop									\ w row-bytes adr xy-adr
		2drop 2drop								\
		;

\	: p-fill-rectangle ( index x y w h display-info -- )
\		dup >I.pixel-depth c@ case						\ index x y w h display_info pixel_depth
\			8 of										\ index x y w h display_info
\				rect-setup								\ w row-bytes index xy-adr h
\				( h ) 0 ?do								\ w row-bytes index xy-adr
\					dup 4 pick 3 pick					\ w row-bytes index xy-adr xy-adr w index
\					fill ( addr len byte -- )			\ w row-bytes index xy-adr
\					2 pick +							\ w row-bytes index xy-adr+=row-bytes
\				loop									\ w row-bytes index xy-adr
\				2drop 2drop								\
\			endof
\														\ index x y w h display_info pixel_depth
\			d# 16 of									\ index x y w h display_info
\				rect-setup								\ w row-bytes index xy-adr h
\				rot swap								\ w row-bytes xy-adr index h
\				( h ) 0 ?do								\ w row-bytes xy-adr index
\					over 4 pick bounds ?do				\ w row-bytes xy-adr index
\						dup i w!						\ w row-bytes xy-adr index
\					/w +loop							\ w row-bytes xy-adr index
\					swap 2 pick + swap					\ w row-bytes xy-adr+=row-bytes index
\				loop									\ w row-bytes xy-adr index
\				2drop 2drop								\
\			endof
\														\ index x y w h display_info pixel_depth
\			d# 32 of									\ index x y w h display_info
\				rect-setup								\ w row-bytes index xy-adr h
\				( h ) 0 ?do								\ w row-bytes index xy-adr
\					dup 4 pick 3 pick					\ w row-bytes index xy-adr xy-adr w index
\					my-filll ( addr len word -- )		\ w row-bytes index xy-adr
\					2 pick +							\ w row-bytes index xy-adr+=row-bytes
\				loop									\ w row-bytes index xy-adr
\				2drop 2drop								\
\			endof
\														\ index x y w h display_info pixel_depth
\			dup of										\ index x y w h display_info
\				5 roll									\ x y w h display_info index
\				4 roll 3 roll							\ x w display_info index y h
\				bounds ?do								\ x w display_info index
\					3 pick 3 pick bounds ?do			\ x w display_info index
\						dup i j 4 pick					\ x w display_info index index x y display_info
\						p-set-pixel						\ x w display_info index
\					loop								\ x w display_info index
\				loop									\ x w display_info index
\				2drop 2drop								\
\			endof										\
\
\
\		endcase											\
\		;


	: p-fill-rectangle ( index x y w h display-info -- )
		4 pick 0< if ( x<0 -- )								\ index x y w h display_info
			>r >r rot +	>r >r 0 r> r> r> r>					\ index x=0 y w+=x h display_info
		then												\ index x y w h display_info
		3 pick 0< if ( y<0 -- )								\ index x y w h display_info
			>r rot + >r	>r 0 r> r> r>						\ index x y=0 w h+=y display_info
		then												\ index x y w h display_info
		dup >T.width w@ 5 pick 4 pick + - dup 0< if			\ index x y w h display_info width-(x+w)
			3 roll + -rot									\ index x y w=width-x h display_info
		else
			drop
		then
		dup >T.height w@ 4 pick 3 pick + - dup 0< if		\ index x y w display_info height-(y+h)
			rot + swap										\ index x y w h=height-y display_info
		else
			drop
		then
		over   0<= if 2drop 2drop 2drop exit then			\ index x y w h display_info
		2 pick 0<= if 2drop 2drop 2drop exit then			\ index x y w h display_info

		5 roll												\ x y w h display_info index
		over >I.pixel-depth c@ dup >r						\ x y w h display_info index depth \ R: depth
		case												\ x y w h display_info index depth \ R: depth
			d#  1 of h# ffffffff endof						\ x y w h display_info index multiplier \ R: depth
			d#  2 of h# 55555555 endof						\ x y w h display_info index multiplier \ R: depth
			d#  4 of h# 11111111 endof						\ x y w h display_info index multiplier \ R: depth
			d#  8 of h# 01010101 endof						\ x y w h display_info index multiplier \ R: depth
			d# 16 of h# 00010001 endof						\ x y w h display_info index multiplier \ R: depth
			d# 32 of h# 00000001 endof						\ x y w h display_info index multiplier \ R: depth
		endcase												\ x y w h display_info index multiplier \ R: depth
		*													\ x y w h display_info pix_vals \ R: depth
\ cr
\ ." pix_vals: " dup 8 u.r cr

		5 roll r@ *											\ y w h display_info pix_vals bit_offset_start=x*depth \ R: depth
\ ." bit_offset_start: " dup .d cr
		dup d# 32 u/mod										\ y w h display_info pix_vals bit_offset_start offset_start long_number_start \ R: depth
\ ." long_number_start: " dup .d cr
\ ." offset_start: " swap dup .d swap cr
		-1 rot >>											\ y w h display_info pix_vals bit_offset_start long_number_start left_mask \ R: depth
\ ." left_mask: " dup 8 u.r cr

		rot 6 roll r> * + 1-								\ y h display_info pix_vals long_number_start left_mask bit_offset_stop=bit_offset_start+w*depth-1
\ ." bit_offset_stop: " dup .d cr

		d# 32 u/mod											\ y h display_info pix_vals long_number_start left_mask offset_stop long_number_stop
\ ." long_number_stop: " dup .d cr
\ ." offset_stop: " swap dup .d swap cr
		-1 rot 1+ >> invert									\ y h display_info pix_vals long_number_start left_mask long_number_stop right_mask=~(-1 >> offset_stop + 1)
\ ." right_mask: " dup 8 u.r cr

		5 roll dup >I.fb-row-bytes l@ tuck					\ y h pix_vals long_number_start left_mask long_number_stop right_mask row_bytes display_info row_bytes
\ ." row_bytes: " dup .d cr
		9 roll * swap >I.fb-address l@ +					\ h pix_vals long_number_start left_mask long_number_stop right_mask row_bytes row_bytes*y+fb_address
		5 pick /l* +										\ h pix_vals long_number_start left_mask long_number_stop right_mask row_bytes left_addr=row_bytes*y+fb_address+long_number_start*4
\ ." left_addr: " dup 8 u.r cr

		\ We don't have optimizations for cases marked "-" (a single long with either left or right pixels)
		\ It's not a problem since such rectangles are relatively narrow and therefore quick to draw.
		\ We do have optimizations for when the pixels are within a single long (the full long or masked long).
		\
		\	LEFT	BYTES	RIGHT
		\	0		0		0			+ "exit"
		\	0		0		1			+ "one masked long"
		\	0		1		0			+ "no left, bytes, no right"	+ "one full long"
		\	0		1		1			+ "no left, bytes, right"		- "no left, long, right"
		\	1		0		0			+ "one masked long"
		\	1		0		1			+ "left, no bytes, right"
		\	1		1		0			+ "left, bytes, no right"		- "left, long, no right"
		\	1		1		1			+ "left, bytes, right"			- "left, long, right"

		3 roll 5 roll -										\ h pix_vals left_mask right_mask row_bytes left_addr longs=long_number_stop-long_number_start
\ ." longs: " dup .d cr
		?dup if												\ h pix_vals left_mask right_mask row_bytes left_addr longs

			/l* \ at least 4 since start != stop			\ h pix_vals left_mask right_mask row_bytes left_addr bytes=longs*4

			4 roll dup -1 = if								\ h pix_vals right_mask row_bytes left_addr bytes left_mask
				drop										\ h pix_vals right_mask row_bytes left_addr bytes
				3 roll dup -1 = if							\ h pix_vals row_bytes left_addr bytes right_mask
					\ no left, bytes, no right
					drop									\ h pix_vals row_bytes left_addr bytes
\ ." no left, bytes, no right " .stack
					la1+ \ at least 8 since start != stop	\ h pix_vals row_bytes left_addr bytes+=4
					-rot									\ h pix_vals bytes row_bytes left_addr
					4 roll 0 do								\ pix_vals bytes row_bytes left_addr
						dup 3 pick 5 pick					\ pix_vals bytes row_bytes left_addr left_addr bytes pix_vals
						my-filll							\ pix_vals bytes row_bytes left_addr
						over +								\ pix_vals bytes row_bytes left_addr+=row_bytes
					loop									\ pix_vals bytes row_bytes left_addr
					\ 4drop									\
				else										\ h pix_vals row_bytes left_addr bytes right_mask
					\ no left, bytes, right
\ ." no left, bytes, right " .stack
					dup 5 pick and							\ h pix_vals row_bytes left_addr bytes right_mask pix_vals_right=right_mask&pix_vals
					swap invert								\ h pix_vals row_bytes left_addr bytes pix_vals_right right_mask=~right_mask
					4 roll 4 roll							\ h pix_vals bytes pix_vals_right right_mask row_bytes left_addr
					6 roll 0 do								\ pix_vals bytes pix_vals_right right_mask row_bytes left_addr
						dup 5 pick 2dup 9 pick				\ pix_vals bytes pix_vals_right right_mask row_bytes left_addr left_addr bytes left_addr bytes pix_vals
						my-filll							\ pix_vals bytes pix_vals_right right_mask row_bytes left_addr left_addr bytes
						+									\ pix_vals bytes pix_vals_right right_mask row_bytes left_addr right_addr=left_addr+bytes
						dup l@ 4 pick and 5 pick or	swap	\ pix_vals bytes pix_vals_right right_mask row_bytes left_addr *right_addr&right_mask|pix_vals_right right_addr
						l!									\ pix_vals bytes pix_vals_right right_mask row_bytes left_addr
						over +								\ pix_vals bytes pix_vals_right right_mask row_bytes left_addr+=row_bytes
					loop									\ pix_vals bytes pix_vals_right right_mask row_bytes left_addr
					2drop \ 6drop							\
				then
				\ 4drop										\
			else											\ h pix_vals right_mask row_bytes left_addr bytes left_mask

				4 roll dup -1 = if							\ h pix_vals row_bytes left_addr bytes left_mask right_mask
					\ left, bytes, no right
					drop									\ h pix_vals row_bytes left_addr bytes left_mask
\ ." left, bytes, no right " .stack
					dup 5 pick and							\ h pix_vals row_bytes left_addr bytes left_mask pix_vals_left=left_mask&pix_vals
					swap invert								\ h pix_vals row_bytes left_addr bytes pix_vals_left left_mask=~left_mask
					4 roll 4 roll							\ h pix_vals bytes pix_vals_left left_mask row_bytes left_addr
					6 roll 0 do								\ pix_vals bytes pix_vals_left left_mask row_bytes left_addr
						dup l@ 3 pick and 4 pick or			\ pix_vals bytes pix_vals_left left_mask row_bytes left_addr *left_addr&left_mask|pix_vals_left
						over l!								\ pix_vals bytes pix_vals_left left_mask row_bytes left_addr
						dup la1+ 5 pick 7 pick				\ pix_vals bytes pix_vals_left left_mask row_bytes left_addr left_addr+4 bytes pix_vals
						my-filll							\ pix_vals bytes pix_vals_left left_mask row_bytes left_addr
						over +								\ pix_vals bytes pix_vals_left left_mask row_bytes left_addr+=row_bytes
					loop									\ pix_vals bytes pix_vals_left left_mask row_bytes left_addr
					\ 6drop									\
				else										\ h pix_vals row_bytes left_addr bytes left_mask right_mask
					\ left, ?, right
					dup 6 pick and							\ h pix_vals row_bytes left_addr bytes left_mask right_mask pix_vals_right=right_mask&pix_vals
					swap invert								\ h pix_vals row_bytes left_addr bytes left_mask pix_vals_right right_mask=~right_mask
					rot dup 7 pick and						\ h pix_vals row_bytes left_addr bytes pix_vals_right right_mask left_mask pix_vals_left=left_mask&pix_vals
					swap invert								\ h pix_vals row_bytes left_addr bytes pix_vals_right right_mask pix_vals_left left_mask=~left_mask
					4 roll 4 -								\ h pix_vals row_bytes left_addr pix_vals_right right_mask pix_vals_left left_mask bytes-=4
					?dup if									\ h pix_vals row_bytes left_addr pix_vals_right right_mask pix_vals_left left_mask bytes
						\ left, bytes, right
\ ." left, bytes, right " .stack
						6 roll 6 roll						\ h pix_vals pix_vals_right right_mask pix_vals_left left_mask bytes row_bytes left_addr
						8 roll 0 do							\ pix_vals pix_vals_right right_mask pix_vals_left left_mask bytes row_bytes left_addr
							dup l@ 4 pick and 5 pick or		\ pix_vals pix_vals_right right_mask pix_vals_left left_mask bytes row_bytes left_addr *left_addr&left_mask|pix_vals_left
							over l!							\ pix_vals pix_vals_right right_mask pix_vals_left left_mask bytes row_bytes left_addr
							dup la1+ 3 pick 2dup d# 11 pick	\ pix_vals pix_vals_right right_mask pix_vals_left left_mask bytes row_bytes left_addr left_addr+4 bytes left_addr+4 bytes pix_vals
							my-filll						\ pix_vals pix_vals_right right_mask pix_vals_left left_mask bytes row_bytes left_addr left_addr+4 bytes
							+								\ pix_vals pix_vals_right right_mask pix_vals_left left_mask bytes row_bytes left_addr right_addr=left_addr+4+bytes
							dup l@ 7 pick and 8 pick or		\ pix_vals pix_vals_right right_mask pix_vals_left left_mask bytes row_bytes left_addr right_addr *right_addr&right_mask|pix_vals_right
							swap l!							\ pix_vals pix_vals_right right_mask pix_vals_left left_mask bytes row_bytes left_addr
							over +							\ pix_vals pix_vals_right right_mask pix_vals_left left_mask bytes row_bytes left_addr+=row_bytes
						loop								\ pix_vals pix_vals_right right_mask pix_vals_left left_mask bytes row_bytes left_addr
						2drop \ 8drop						\
					else									\ h pix_vals row_bytes left_addr pix_vals_right right_mask pix_vals_left left_mask
						\ left, no bytes, right
\ ." left, no bytes, right " .stack
						2rot 6 roll drop					\ h pix_vals_right right_mask pix_vals_left left_mask row_bytes left_addr
						6 roll 0 do							\ pix_vals_right right_mask pix_vals_left left_mask row_bytes left_addr
							dup l@ 3 pick and 4 pick or		\ pix_vals_right right_mask pix_vals_left left_mask row_bytes left_addr *left_addr&left_mask|pix_vals_left
							over l!							\ pix_vals_right right_mask pix_vals_left left_mask row_bytes left_addr
							dup la1+						\ pix_vals_right right_mask pix_vals_left left_mask row_bytes left_addr right_addr=left_addr+4
							dup l@ 6 pick and 7 pick or		\ pix_vals_right right_mask pix_vals_left left_mask row_bytes left_addr right_addr *right_addr&right_mask|pix_vals_right
							swap l!							\ pix_vals_right right_mask pix_vals_left left_mask row_bytes left_addr
							over +							\ pix_vals_right right_mask pix_vals_left left_mask row_bytes left_addr+=row_bytes
						loop								\ pix_vals_right right_mask pix_vals_left left_mask row_bytes left_addr
						\ 6drop								\
					then									\
					\ 6drop									\
				then
				2drop \ 6drop
			then
			2drop \ 4drop
		else												\ h pix_vals left_mask right_mask row_bytes left_addr
			2swap and										\ h pix_vals row_bytes left_addr mask=left_mask&right_mask
			dup -1 = if										\ h pix_vals row_bytes left_addr mask
				\ one full long
\ ." one full long " .stack
				drop										\ h pix_vals row_bytes left_addr
				3 roll 0 do									\ pix_vals row_bytes left_addr
					2 pick over l!							\ pix_vals row_bytes left_addr
					over +									\ pix_vals row_bytes left_addr+=row_bytes
				loop										\ row_bytes pix_vals left_addr
				drop \ 3drop								\
			else											\ h pix_vals row_bytes left_addr mask
				\ one masked long
\ ." one masked long " .stack
				dup 4 roll and								\ h row_bytes left_addr mask pix_vals&=mask
				swap invert									\ h row_bytes left_addr pix_vals mask=!mask
				2swap										\ h pix_vals mask row_bytes left_addr
				4 roll 0 do									\ pix_vals mask row_bytes left_addr
					dup l@ 3 pick and 4 pick or over		\ pix_vals mask row_bytes left_addr *left_addr&mask|pix_vals left_addr
					l!										\ pix_vals mask row_bytes left_addr
					over +									\ pix_vals mask row_bytes left_addr+=row_bytes
				loop										\ pix_vals mask row_bytes left_addr
				2drop \ 4drop								\
			then											\
			\ 2drop											\
		then												\
		2drop
		;

	: p-read-rectangle ( adr x y w h display-info -- )
		rect-setup								\ w row-bytes adr xy-adr h
		>r >r >r swap r> r> swap r>				\ row-bytes w xy-adr adr h
		( h ) 0 ?do								\ row-bytes w xy-adr adr
			2dup 5 pick							\ row-bytes w xy-adr adr xy-adr adr w
			move ( src-addr dest-addr len -- )	\ row-bytes w xy-adr adr
			2over pick d+						\ row-bytes w xy-adr+row-bytes adr+w
			loop								\ row-bytes w xy-adr adr
		2drop 2drop								\
		;

	: p-fill-ellipse ( color left top w h display-info -- )
\ cr ." start: " .s
		over   0<= if 2drop 2drop 2drop exit then			\ index left top w h display_info
		2 pick 0<= if 2drop 2drop 2drop exit then			\ index left top w h display_info
		rot													\ index left top h display_info rx.1																					\	rx=w/2
\ ." rx.1 stack: " .s
		4 roll 2* over +									\ index top h display_info rx.1 center.1=rx.1+left.1																	\	xcenter=left+rx
\ ." center.1 stack: " .s
		swap dup um* drop									\ index top h display_info xcenter.1 rx2.2=rx.1*rx.1																	\	rx2=rx*rx
\ ." rx2.2 stack: " .s
		3 roll 4 roll 2dup + 1-								\ index display_info xcenter.1 rx2.2 h top bottom=h+top-1																\	bottom=top+h
\ ." bottom stack: " .s
		rot													\ index display_info xcenter.1 rx2.2 top bottom ry.1=h/2																\	ry=h/2
\ ." ry.1 stack: " .s
		dup dup um* drop									\ index display_info xcenter.1 rx2.2 top bottom ry.1 ry2.2																\	ry2=ry*ry
\ ." ry2.2 stack: " .s
		4 roll over 0 -rot um/								\ index display_info xcenter.1 top bottom ry.1 ry2.2 rx2_ry2.32=rx2.34/ry2.2											\	rx2_ry2 = rx2 / ry2
\ ." rx2_ry2.32 stack: " .s
		3 roll dup 1-										\ index display_info xcenter.1 top bottom ry2.2 rx2_ry2.32l rx2_ry2.32h ry.1 y.1=ry.1-0.5								\	y = ry - 0.5
\ ." y.1 stack: " .s
		swap 1+ u2/ 0 do									\ index display_info xcenter.1 top bottom ry2.2 rx2_ry2.32l rx2_ry2.32h y.1=ry.1-0.5									\	for i = 0 to round(ry) {
\ ." loop stack: " .s
			3 pick over dup um* drop - 2over rot			\ index display_info xcenter.1 top bottom ry2.2 rx2_ry2.32l rx2_ry2.32h y.1 rx2_ry2.32l rx2_ry2.32h ry2.2-y2.2			\		len = isqrt((ry2 - y*y)*rx2_ry2)
\ ." diff stack: " .s
			ud* nip isqrt									\ index display_info xcenter.1 top bottom ry2.2 rx2_ry2.32l rx2_ry2.32h y.1 len.1=√(rx2_ry2.32*(ry2.2-y2.2))			\
\ ." len.1 stack: " .s
			9 pick 8 pick 2 pick - 2/ 8 pick i +			\ index display_info xcenter.1 top bottom ry2.2 rx2_ry2.32l rx2_ry2.32h y.1 len.1 index floor(xcenter.1-len.1) top+i	\		fill_rectangle(color, xcenter - len, top + i, xcenter + len - xcenter - len, 1)
			d# 10 pick 4 pick +	1+ 2/ 2 pick -				\ round(xcenter.1+len.1)-floor(xcenter.1-len.1)
			1 d# 13 pick									\ 1 display_info
\ ." fill-rectangle stack: " .s
			p-fill-rectangle
			9 pick 8 pick 2 pick - 2/ 7 pick i -			\ index display_info xcenter.1 top bottom ry2.2 rx2_ry2.32l rx2_ry2.32h y.1 len.1 index	floor(xcenter.1-len.1) top+i	\		fill_rectangle(color, xcenter - len, bottom - i, len * 2, 1)
			d# 10 pick 4 pick +	1+ 2/ 2 pick -				\ round(xcenter.1+len.1)-floor(xcenter.1-len.1)
			1 d# 13 pick									\ 1 display_info
\ ." fill-rectangle stack: " .s
			p-fill-rectangle
			drop 2-											\ index display_info xcenter.1 top bottom ry2.2 rx2_ry2.32l rx2_ry2.32h y.1=y.1-1										\		y -= 1
		loop												\ index display_info xcenter.1 top bottom ry2.2 rx2_ry2.32l rx2_ry2.32h y.1												\	}
\ ." done stack: " .s
		2drop 2drop 2drop 3drop								\																														\
\ ." exit stack: " .s
		;

	: p-test-pattern ( display-info -- )
		dup p-dimensions				\ display_info width height
		swap d# 16 /					\ display_info height width/16
		swap d# 16 /					\ display_info width/16 height/16
		d# 16 0 do \ y					\ display_info width/16 height/16
			d# 16 0 do \ x				\ display_info width/16 height/16
				i j + F and				\ display_info width/16 height/16 color
				3 pick >I.pixel-depth c@ case
					1 of
						1 and
					endof
					2 of
						3 and
					endof
					d# 16 of
						3 * std-16 + c@++ c@++ c@ 3 >> swap 3 >> 5 << or swap 3 >> d# 10 << or
					endof
					d# 32 of
						3 * std-16 + c@++ c@++ c@ swap 8 << or swap d# 16 << or
					endof
				endcase

				2 pick i *				\ display_info width/16 height/16 color x
				2 pick j *				\ display_info width/16 height/16 color x y
				4 pick					\ display_info width/16 height/16 color x y w
				4 pick					\ display_info width/16 height/16 color x y w h
				7 pick					\ display_info width/16 height/16 color x y w h display_info
				p-fill-rectangle		\ display_info width/16 height/16
			loop						\ display_info width/16 height/16
		loop							\ display_info width/16 height/16
		3drop							\
		;

	: p-show-modes-all ( display-info -- )
		cr
		['] dump-display-timing-cr to timing-proc
		loop-timings-all ( display-info -- )
		;

	: p-show-modes ( display-info -- )
		cr
		['] dump-display-timing-cr to timing-proc
		loop-timings-display ( display-info -- )
		;

	: p-clear-screen ( display-info -- )
		" [ p-clear-screen" .dbg cr
		dup >I.fb-address l@			\ display_info fb-address
		" fb-address: " .dbg dup 8 u.r cr

		over >I.fb-row-bytes l@			\ display_info fb-address fb-row-bytes
		" fb-row-bytes: " .dbg dup .d cr

		2 pick >T.height w@
		" height: " .dbg dup .d cr

		*			\ display_info fb-address fb-row-bytes*height
		rot >I.pixel-depth c@
		" pixel-depth: " .dbg dup .d cr

		case		\ fb-address fb-row-bytes*height depth
			    8 of    d# 15    fill  ( addr len byte -- ) endof
			d# 16 of 7fff7fff my-filll ( addr len word -- ) endof
			d# 32 of   ffffff my-filll ( addr len word -- ) endof
			  dup of       -1    fill  ( addr len byte -- ) endof
		endcase
		" ] p-clear-screen" .dbg cr
		;

\		dup >I.pixel-depth c@ case
\			1 of d# 1 endof
\			2 of d# 3 endof
\			4 of d# 15 endof
\			8 of d# 15 endof
\			d# 16 of h# 7fff endof
\			d# 32 of h# ffffff endof
\			cr ." illegal depth: " .d cr
\			D15C0002 throw
\		endcase																	\ display_info index
\		0 0																		\ display_info index 0 0
\		3 pick >T.width w@														\ display_info index 0 0 width
\		4 pick >T.height w@														\ display_info index 0 0 width height
\		5 roll																	\ index 0 0 width height display_info
\		p-fill-rectangle ( index x y w h display-info -- )
\		;

	: update-property-int ( int name-str name-len display-info -- )
		>I.phandle l@															\ int name-str name-len phandle
		3dup get-package-property ( name-str name-len phandle -- true | prop-addr prop-len false )
		if																		\ int name-str name-len phandle
			drop rot encode-int 2swap											\ prop-addr prop-len name-str name-len
			property															\
		else																	\ int name-str name-len phandle prop-addr prop-len
			drop 4 roll	swap													\ name-str name-len phandle int prop-addr
			4c!-be																\ name-str name-len phandle
			3drop																\
		then
		;

	: update-property-empty ( name-str name-len display-info -- )
		>I.phandle l@															\ name-str name-len phandle
		3dup get-package-property ( name-str name-len phandle -- true | prop-addr prop-len false )
		if																		\ name-str name-len phandle
			drop 0 0 2swap														\ prop-addr prop-len name-str name-len
			property															\
		else																	\ name-str name-len phandle prop-addr prop-len
			2drop 3drop															\
		then
		;

	: init-display ( display-timing display-info -- )
		" [ init-display " .dbg over dump-display-timing cr										\ display-timing display_info
		dup " display-info: " .dbg 8 u.r cr														\ display-timing display_info

		tuck >I.current-timing /display-timing													\ display_info display-timing &display_info.current-timing /display-timing
		move ( src-addr dest-addr len -- )														\ display_info

		dup >I.display-regs l@																	\ display_info regs
		dup " display-regs: " .dbg 8 u.r cr

		over >T.pixel-clock   l@ dup " pixclock: " .dbg .d cr over >D.pixel-clock			l!	\ display_info regs
		over >T.hactive       w@ dup " hactive: "  .dbg .d cr over >D.hactive				l!	\ display_info regs
		over >T.hsyncbegin    w@ dup " hsyncbeg: " .dbg .d cr over >D.hsyncbegin			l!	\ display_info regs
		over >T.hsyncend      w@ dup " hsyncend: " .dbg .d cr over >D.hsyncend				l!	\ display_info regs
		over >T.htotal        w@ dup " htotal: "   .dbg .d cr over >D.htotal				l!	\ display_info regs
		over >T.vactive       w@ dup " vactive: "  .dbg .d cr over >D.vactive				l!	\ display_info regs
		over >T.vsyncbegin    w@ dup " vsyncbeg: " .dbg .d cr over >D.vsyncbegin			l!	\ display_info regs
		over >T.vsyncend      w@ dup " vsyncend: " .dbg .d cr over >D.vsyncend				l!	\ display_info regs
		over >T.vtotal        w@ dup " vtotal: "   .dbg .d cr over >D.vtotal				l!	\ display_info regs

		over >I.fb-base       l@ dup " fbbase: "   .dbg .d cr over >D.framebuffer-base		l!	\ display_info regs
		over >I.pixel-depth   c@ dup " depth: "    .dbg .d cr over >D.pixel-depth			l!	\ display_info regs
		0                        dup " int-en: "   .dbg .d cr over >D.int-enable			l!	\ display_info regs

		over >T.hpolarity     c@ dup " hpol: "     .dbg .d cr >r								\ display_info regs \ R: hpolarity
		over >T.vpolarity     c@ dup " vpol: "     .dbg .d cr >r								\ display_info regs \ R: hpolarity vpolarity
		over >T.interlaced    c@ dup " interlac: " .dbg .d cr >r								\ display_info regs \ R: hpolarity vpolarity interlaced
		r> if 1 else 0 then																		\ display_info regs interlaced_bit \ R: hpolarity vpolarity
		r> if 2 else 0 then +																	\ display_info regs interlaced_bit+vpolarity_bit \ R: hpolarity
		r> if 4 else 0 then +																	\ display_info regs interlaced_bit+vpolarity_bit+hpolarity_bit
		                         dup " timflgs: "  .dbg .d cr over >D.timing-flags			l!	\ display_info regs

		over >T.width w@ 2 pick																	\ display_info regs width display_info
		        p-calc-row-bytes tuck															\ display_info row-bytes regs row-bytes
								 dup " rowbytes: " .dbg .d cr over >D.framebuffer-rowbytes	l!	\ display_info row-bytes regs
		drop												  over >I.fb-row-bytes l!			\ display_info
		dup >T.csyncdisabled  c@ dup " csyncdis: " .dbg .d cr									\ display_info csyncdisabled
				if h# 10 else 0 then                          over >I.im-flags-to-set        l!	\ display_info


		dup >I.pixel-depth c@ case
			d# 1 of
				dup p-set-2-colors
			endof
			d# 2 of
				dup p-set-4-colors
			endof
			d# 4 of
				dup p-set-16-colors
			endof
			d# 8 of
				dup p-set-16-colors
			endof
		endcase

		dup p-enable-display ( display-info -- )												\ display_info
		dup p-clear-screen ( display-info -- )													\ display_info

		" [ set-font" .dbg cr
		default-font set-font																	\ display_info
		" ] set-font" .dbg cr

		h# 168 get-token drop																	\ display_info foreground-color
		['] ferror																				\ display_info foreground-color ferror
		<> if																					\ display_info
			\ Set iso6429-1983-colors before fb8-install so fb8-install will know to set
			\ foreground-color to 0 (black) and background color to 15 (white) instead of
			\ foreground-color to 255 and background color to 0.
			" [ iso6429-1983-colors" .dbg cr
			" iso6429-1983-colors" 2 pick update-property-empty									\ display_info
			" ] iso6429-1983-colors" .dbg cr
		then

		\ Note: we don't have an fb16 or fb32 option - text will only be correct
		\ for pixel-depth = 8

			dup >T.width w@ over >T.height w@ over 20 - char-width / over 20 - char-height /	\ display_info width height (width-20)/char-width (height-20)/char-height
			.stack
			" fb8-install ( width height #columns #lines -- )" .dbg cr
			fb8-install ( width height #columns #lines -- )										\ display_info

			dup >I.pixel-depth c@ case
				d# 16 of
					h# ff 0 to foreground-color to background-color
				endof
				d# 32 of
					h# ff 0 to foreground-color to background-color
				endof
			endcase

		\ window-left and window-top are automatically set by fb8-install
		\ but we want to make sure they the text area is centered (which might not
		\ happen with some implementations of Open Firmware)

			dup >T.width w@ #columns char-width * - 2/											\ display_info (width-(#columns * char-width))/2
			" window-left     : " .dbg dup . cr
			to window-left																		\ display_info

			dup >T.height w@ #lines char-height * - 2/											\ display_info (height-(#lines * char-height))/2
			" window-top      : " .dbg dup . cr
			to window-top																		\ display_info

		dup >I.fb-address l@
		" frame-buffer-adr: " .dbg dup 8 u.r cr
		to frame-buffer-adr																		\ display_info

		dup >T.width  w@        " width"     3 pick update-property-int							\ display_info
		dup >T.height w@        " height"    3 pick update-property-int							\ display_info
		dup >I.fb-row-bytes l@	" linebytes" 3 pick update-property-int							\ display_info
		dup >I.pixel-depth c@   " depth"     3 pick update-property-int							\ display_info

		drop

		" ] init-display" .dbg cr
		;

	0 value timing-number-to-find
	false value timing-found?

	: find-and-set-mode ( display-timing display-info -- done? )
		over >T.mode w@ timing-number-to-find = if							\ display-timing display_info
			true to timing-found?											\ display-timing display_info
			2dup valid-timing? ( display-timing display-info -- isvalid? )	\ display-timing display_info isvalid?
			if																\ display-timing display_info
				." found mode: " over dump-display-timing cr				\ display-timing display_info
				init-display ( display-timing display-info -- )				\
			else															\ display-timing display_info
				drop														\ display-timing
				." not enough vram for mode: " dump-display-timing cr		\
			then
			true															\ done
			exit															\
		then																\ display-timing display_info
		2drop																\
		false																\ continue
		;

	: p-set-best-mode ( display-info -- )
		" [ set-best-mode ( display-info -- )" .dbg cr
		best-display-timing /display-timing erase ( addr len -- )			\ display_info
		['] greatest-display-timing to timing-proc
\		.stack
		dup loop-timings-display ( display-info -- )						\ display_info
\		.stack
		best-display-timing >T.mode w@ if									\ display_info
			best-display-timing												\ display_info display-timing
			" best mode: " .dbg dup dump-display-timing cr
		else
			." no modes - using VGA mode" cr
			kDisplay_640x480_60Hz_VGA
			" VGA mode: " .dbg dup dump-display-timing cr
		then
		over																\ display_info display-timing display_info
		init-display ( display-timing display-info -- )						\ display_info
		drop																\
\		.stack
		" ] set-best-mode" .dbg cr
		;

	: p-set-mode ( mode display-info -- )
		swap to timing-number-to-find										\ display_info
		false to timing-found?												\ display_info
		['] find-and-set-mode to timing-proc								\ display_info
		loop-timings-all ( display-info -- )								\
		timing-found? not if												\
			." mode not found" cr											\
		then																\
		;

	: p-get-mode ( display-info -- mode )
		>T.mode w@ ;

	: p-set-depth ( depth display-info -- )
		" [ set-depth" .dbg cr
		over																\ depth display_info depth
		case																\ depth display_info depth
			d# 1 of endof													\ depth display_info
			d# 2 of endof													\ depth display_info
			d# 4 of endof													\ depth display_info
			d# 8 of endof													\ depth display_info
			d# 16 of endof													\ depth display_info
			d# 32 of endof													\ depth display_info
			cr ." illegal depth: " .d cr									\ depth display_info
			D15C0003 throw													\ depth display_info
		endcase																\ depth display_info
		2dup dup >T.width w@ swap >T.height w@								\ depth display_info depth width height
		is-valid-frame-buffer-bytes? if										\ depth display_info
			tuck >I.pixel-depth												\ display_info depth &pixel-depth
			c! dup															\ display_info
			init-display ( display-timing display-info -- )					\
		else
			2drop
			." not enough vram" cr
		then
		" ] set-depth" .dbg cr
		;

	: p-get-depth ( display-info -- depth )
		>I.pixel-depth c@ ;

	-1 value vram-base-phys
	0 value parent-open-count

	: p-my-open ( display-info -- )
		" [ open #" .dbg dup >I.display-number c@ .d ." count: " dup >I.open-count l@ .d cr
		.stack

		" check open count" .dbg cr

		dup >I.open-count l@ 0= if												\ display_info

			dup >I.display-number c@ /display-regs * /meta-regs + vram-base +	\ display_info display-regs
			dup " set display-regs: " .dbg 8 u.r cr
			over >I.display-regs l!

			dup >I.display-number c@ vram-per-display * all-regs-size +			\ display_info base
			dup " set framebuffer-base: " .dbg 8 u.r cr
			2dup swap >I.fb-base l!												\ display_info base

			vram-base +															\ display_info base+vram-base
			dup " set fb-address: " .dbg 8 u.r cr
			over >I.fb-address l!												\ display_info

			.stack
			dup reset-display ( display-info -- )								\ display_info

			dup get-mon-sense ( display-info -- )								\ display_info
			dup >I.sense-code w@												\ display_info sense-code
			" sense-code" 3 pick update-property-int							\ display_info

			.stack
			dup read-edid ( display-info -- )									\ display_info
			.stack

			dup p-set-std-gamma ( display-info -- )

			dup p-set-best-mode ( display-info -- )								\ display_info display-timing
		else
			" skip display-regs" .dbg cr
		then

		dup >I.open-count dup l@ 1+ swap l!														\ display_info

		" display-regs    : " .dbg dup >I.display-regs     l@ 8 u.r cr
		" fb-address      : " .dbg dup >I.fb-address       l@ 8 u.r cr
		" im-flags-to-set : " .dbg dup >I.im-flags-to-set  l@ 8 u.r cr
		" width           : " .dbg dup >T.width            w@ .d cr
		" height          : " .dbg dup >T.height           w@ .d cr
		" display-number  : " .dbg dup >I.display-number   c@ .d cr
		" mono-mode?      : " .dbg dup >I.mono-mode?       c@ .d cr

		.stack
		" ] open #" .dbg dup >I.display-number c@ .d ." count: " dup >I.open-count l@ .d cr

		drop
		.stack
		;

	: p-my-close ( display-info -- )

		" [ close #" .dbg dup >I.display-number c@ .d ." count: " dup >I.open-count l@ .d cr
		.stack

		dup >I.open-count l@ if																		\ display_info
			dup >I.open-count l@ 1 = if																\ display_info
\				unallocate
			then																					\ display_info
			dup >I.open-count dup l@ 1- swap l!														\ display_info
			.stack
		then																						\ display_info

		" ] close #" .dbg dup >I.display-number c@ .d ." count: " dup >I.open-count l@ .d cr
		drop																						\ display_info
		.stack
		;

	: open-parent
		cr
		" [ open count: " .dbg parent-open-count .d cr
		.stack

		parent-open-count 0= if													\
			" assigned-addresses" get-my-property ( name-str name-len -- true | prop-addr prop-len false )
			" abort"" no assigned-addresses property""" evaluate			\ prop-addr prop-len
			begin															\ prop-addr prop-len
				dup 0>														\ prop-addr prop-len (prop-len > 0)
			while															\ prop-addr prop-len
				decode-int h# FF and >r decode-int drop decode-int >r		\ prop-addr prop-len \ R: BAR=(int0 & 0xff) phys
				8 - swap 8 + swap ( prop-adr prop-len )						\ prop-addr+=8 prop-len-=8 \ skip size
				r> r> case													\ prop-addr prop-len phys BAR
					h# 10 of												\ prop-addr prop-len phys
						to vram-base-phys									\ prop-addr prop-len
					endof													\ prop-addr prop-len
																			\ prop-addr prop-len phys BAR
					nip														\ prop-addr prop-len BAR
				endcase														\ prop-addr prop-len
			repeat															\ prop-addr prop-len
			2drop															\

			vram-base-phys 0 parent-space h# 42000010 or vram-size			\ vram-base-phys 0 my-space|42000000 regs-size
			.stack
			" map-in bar 10" .dbg cr
			map-in to vram-base
			parent-open-count 1+ to parent-open-count
			.stack
		then

		" ] open count: " .dbg parent-open-count .d cr
		;

	: close-parent
		" [ close count: " .dbg parent-open-count .d cr

		.stack
		parent-open-count if
			parent-open-count 1 = if
				vram-base vram-size
				.stack
				" map-out bar 10" .dbg cr
				map-out ( virt size -- )
			then
			parent-open-count 1- to parent-open-count
			.stack
		then

		" ] close count: " .dbg parent-open-count .d cr
		;

	['] open-parent is-install
	['] close-parent is-remove

	\ ========================================================================================
	\ Children

	\ This is used like this: " findme" byte-load-from-rom
	\ It will execute the fcode that is preceded by a matching string literal and begins with a start1 fcode (0xF1).
	: byte-load-from-rom ( str len -- ? )
		" [ byte-load-from-rom" .dbg cr
			rombar-size						\ str len rombar-size
			over							\ str len rombar-size str
			-								\ str len rombar-size-str
			rom-base						\ str len rombar-size-str rom-base
			swap							\ str len rom-base rombar-size-str
			bounds							\ str len rom-base+rombar-size-str rom-base
			?do								\ str len
				2dup i						\ str len str len i
				swap						\ str len str i len
				comp						\ str len (0=equal|not 0=not equal)
				0=							\ str len equal?
				over i +					\ str len equal? len+i
				c@ f1 =						\ str len equal? *(len+i)==f1
				and							\ str len (equal and followed by f1)
				if							\ str len
					" found fcode" .dbg cr
					nip						\ len
					i +						\ i+len \ skip bytes for str (len)
					unloop \ required for exit
					1 byte-load				\ ( addr xt -- )
					" ] byte-load-from-rom" .dbg cr
					exit
					\ 0 0 leave
				then						\ str len
			loop							\ str len
			2drop							\
		" ] byte-load-from-rom fcode not found" .dbg cr
		;

	: create-displays
		\ this has to be done from compiled code because of Open Firmware 1.0.5
		num-displays 0 ?do
			i new-device " fcode_DingusVideo" byte-load-from-rom finish-device
		loop
		;
	create-displays

	\ ========================================================================================
	\ Parent epilogue

	.stack

	30 my-config-l@ dup " rombar: " .dbg 8 u.r cr
	-2 and          dup " rombar: " .dbg 8 u.r cr
	30 my-config-l!

	rom-base rombar-size
	.stack
	" map-out rom" .dbg cr
	map-out

	rombar-old      dup " rombar: " .dbg 8 u.r cr
	30 my-config-l!

	0 to rom-base
	" ] rom-mapped" .dbg cr

	" DingusVideoParent" device-name

	.stack
" ] DingusVideoParent" .dbg cr

fcode-end

\ ========================================================================================
\ Child

" fcode_DingusVideo"
fcode-version2 ( display-number -- )

	" [ DingusVideo #" .dbg dup . cr
	.stack

	create display-info
	display-info /display-info dup allot
	0 fill ( addr len byte -- )

	  display-info >I.display-number c!
	8 display-info >I.pixel-depth c!

	my-self ( -- ihandle )
		dup " ihandle: " .dbg 8 u.r cr
		ihandle>phandle ( ihandle -- phandle )
		dup " phandle: " .dbg 8 u.r cr
		display-info >I.phandle l!

	" making new device" .dbg cr
	.stack

	" DingusVideo_A" encode-string 2dup + 2- 41 display-info >I.display-number c@ + swap c! " name" property
	" DingusVideo" encode-string " compatible" property

	has-unit-address if
		" making new device reg" .dbg cr
		display-info >I.display-number c@ encode-int " reg" property
	then

	0 value latest-my-self
	0 value old-my-self

	: do-it ( xt -- ? )
		my-self dup to old-my-self
		0= if
			." no instance set; setting it to " latest-my-self 8 u.r cr
			latest-my-self to my-self
			latest-my-self to old-my-self
		else
			my-self ihandle>phandle display-info >I.phandle l@ <> if
				." instance belongs to " my-self ihandle>phandle 8 u.r ." ; setting it to " latest-my-self 8 u.r cr
				latest-my-self to my-self
			then
		then

		my-self 0= if
			drop
			cr ." no instance set" cr
			D15C0001 throw
		else
			display-info swap execute
		then

		old-my-self my-self <> if
			." setting instance back to " old-my-self 8 u.r cr
			old-my-self to my-self
		then
		;

	external

	: dimensions			( -- width height )			['] p-dimensions            do-it ;
	: set-colors			( adr index #indices )		['] p-set-colors            do-it ;
	: get-colors			( adr index #indices -- )	['] p-get-colors            do-it ;
	: color!				( r g b index -- )			['] p-color!                do-it ;
	: color@				( index -- r g b )			['] p-color@                do-it ;
	: draw-rectangle		( adr x y w h -- )			['] p-draw-rectangle        do-it ;
	: fill-rectangle		( index x y w h -- )		['] p-fill-rectangle        do-it ;
	: fill-ellipse			( color x y w h -- )		['] p-fill-ellipse          do-it ;

	: read-rectangle		( adr x y w h -- )			['] p-read-rectangle        do-it ;
	: set-pixel				( index x y -- )			['] p-set-pixel             do-it ;

	: clear-screen			( -- )						['] p-clear-screen          do-it ;
	: test-pattern			( -- )						['] p-test-pattern          do-it ;

	: show-modes-all		( -- )						['] p-show-modes-all        do-it ;
	: show-modes			( -- )						['] p-show-modes            do-it ;

	: set-best-mode			( -- )						['] p-set-best-mode         do-it ;
	: set-mode				( mode -- )					['] p-set-mode              do-it ;
	: get-mode				( -- mode )					['] p-get-mode              do-it ;
	: set-depth				( depth -- )				['] p-set-depth             do-it ;
	: get-depth				( -- depth )				['] p-get-depth             do-it ;
	: set-16-colors			( -- )						['] p-set-16-colors         do-it ;
	: set-std-gamma			( -- )						['] p-set-std-gamma         do-it ;
	: enable-display		( -- )						['] p-enable-display        do-it ;
	: .display-info			( -- )						display-info p-.display-info      ;

	: edid-revision			( -- revision )				display-info p-edid-revision      ;
	: edid-analog?			( -- analog? )				display-info p-edid-analog?       ;
	: edid-monochrome?		( -- monochrome? )			display-info p-edid-monochrome?   ;
	: edid-supports-cvt?	( -- supports_cvt? )		display-info p-edid-supports-cvt? ;

	headerless ( external )

	: my-open  ( -- )
		my-self to latest-my-self
		display-info p-my-open
		;

	: my-close ( -- )
		0 to latest-my-self
		display-info p-my-close
		;

	['] my-open  is-install
	['] my-close is-remove

	.stack
	" ] DingusVideo #" .dbg display-info >I.display-number c@ . cr
fcode-end

\ ========================================================================================

pci-end
